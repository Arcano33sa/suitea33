// --- IndexedDB helpers POS
const DB_NAME = 'a33-pos';
const DB_VER = 22; // schema estable
let db;

// --- Finanzas: conexión a finanzasDB para asientos automáticos
const FIN_DB_NAME = 'finanzasDB';
const FIN_DB_VER = 1;
let finDb;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded = (e) => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains('products')) {
        const os = d.createObjectStore('products', { keyPath: 'id', autoIncrement: true });
        os.createIndex('by_name', 'name', { unique: true });
      }
      if (!d.objectStoreNames.contains('events')) {
        const os2 = d.createObjectStore('events', { keyPath: 'id', autoIncrement: true });
        os2.createIndex('by_name', 'name', { unique: true });
      }
      if (!d.objectStoreNames.contains('sales')) {
        const os3 = d.createObjectStore('sales', { keyPath: 'id', autoIncrement: true });
        os3.createIndex('by_date', 'date', { unique: false });
        os3.createIndex('by_event', 'eventId', { unique: false });
      } else {
        try { e.target.transaction.objectStore('sales').createIndex('by_date','date'); } catch {}
        try { e.target.transaction.objectStore('sales').createIndex('by_event','eventId'); } catch {}
      }
      if (!d.objectStoreNames.contains('inventory')) {
        const inv = d.createObjectStore('inventory', { keyPath: 'id', autoIncrement: true });
        inv.createIndex('by_event', 'eventId', { unique: false });
      } else {
        try { e.target.transaction.objectStore('inventory').createIndex('by_event','eventId'); } catch {}
      }
      if (!d.objectStoreNames.contains('meta')) {
        d.createObjectStore('meta', { keyPath: 'id' });
      }
      if (!d.objectStoreNames.contains('pettyCash')) {
        d.createObjectStore('pettyCash', { keyPath: 'eventId' });
      }
    };
    req.onsuccess = () => { db = req.result; resolve(db); };
    req.onerror = () => reject(req.error);
  });
}

// --- Finanzas: helpers para abrir finanzasDB y crear/borrar asientos
function openFinanzasDB() {
  return new Promise((resolve, reject) => {
    if (finDb) return resolve(finDb);
    const req = indexedDB.open(FIN_DB_NAME, FIN_DB_VER);
    req.onupgradeneeded = (e) => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains('accounts')) {
        const accStore = d.createObjectStore('accounts', { keyPath: 'code' });
        accStore.createIndex('type', 'type', { unique: false });
      }
      if (!d.objectStoreNames.contains('journalEntries')) {
        const entriesStore = d.createObjectStore('journalEntries', { keyPath: 'id', autoIncrement: true });
        entriesStore.createIndex('date', 'date', { unique: false });
        entriesStore.createIndex('tipoMovimiento', 'tipoMovimiento', { unique: false });
        entriesStore.createIndex('evento', 'evento', { unique: false });
        entriesStore.createIndex('origen', 'origen', { unique: false });
        entriesStore.createIndex('origenId', 'origenId', { unique: false });
      }
      if (!d.objectStoreNames.contains('journalLines')) {
        const linesStore = d.createObjectStore('journalLines', { keyPath: 'id', autoIncrement: true });
        linesStore.createIndex('entryId', 'entryId', { unique: false });
        linesStore.createIndex('accountCode', 'accountCode', { unique: false });
      }
    };
    req.onsuccess = (e) => {
      finDb = e.target.result;
      resolve(finDb);
    };
    req.onerror = () => {
      console.error('Error abriendo finanzasDB desde POS', req.error);
      reject(req.error);
    };
  });
}

async function ensureFinanzasDB() {
  try {
    await openFinanzasDB();
  } catch (e) {
    console.error('No se pudo abrir finanzasDB para asientos automáticos', e);
    throw e;
  }
}

// Mapea forma de pago del POS a cuenta contable
function mapSaleToCuentaCobro(sale) {
  const pay = sale.payment || 'efectivo';
  if (pay === 'efectivo') return '1100';   // Caja
  if (pay === 'transferencia') return '1200'; // Banco
  if (pay === 'credito') return '1300';    // Clientes
  return '1200'; // Otros métodos similares a banco
}

// Crea/actualiza asiento automático en Finanzas por una venta / devolución del POS
async function createJournalEntryForSalePOS(sale) {
  try {
    if (!sale) return;
    // Cortesías: por ahora NO se contabilizan ingresos ni costo de venta
    if (sale.courtesy) return;

    await ensureFinanzasDB();

    const saleId = sale.id != null ? sale.id : null;

    // Importe de ingreso (venta neta)
    const amount = Math.abs(Number(sale.total) || 0);

    // Costo de venta basado en costo por presentación
    let unitCost = 0;
    if (typeof sale.costPerUnit === 'number' && sale.costPerUnit > 0) {
      unitCost = sale.costPerUnit;
    } else {
      unitCost = getCostoUnitarioProducto(sale.productName || '');
    }
    const qtyAbs = Math.abs(Number(sale.qty) || 0);
    const amountCost = unitCost > 0 && qtyAbs > 0 ? unitCost * qtyAbs : 0;

    // Si no hay ni ingreso ni costo, no hay nada que registrar
    if (!amount && !amountCost) return;

    const cashAccount = mapSaleToCuentaCobro(sale);
    const evento = sale.eventName || '';
    const descripcionBase = sale.productName || 'Venta POS';
    const descripcion = sale.isReturn
      ? `Devolución POS - ${descripcionBase}`
      : `Venta POS - ${descripcionBase}`;

    // Para devoluciones lo marcamos como "ajuste" para diferenciarlo visualmente
    const tipoMovimiento = sale.isReturn ? 'ajuste' : 'ingreso';

    const totalsDebe = amount + amountCost;
    const totalsHaber = amount + amountCost;

    // Buscar si ya existe un asiento para este origen/origenId
    let existingEntry = null;
    if (saleId != null) {
      await new Promise((resolve) => {
        const txRead = finDb.transaction(['journalEntries'], 'readonly');
        const storeRead = txRead.objectStore('journalEntries');
        const req = storeRead.getAll();
        req.onsuccess = () => {
          const list = req.result || [];
          existingEntry = list.find(
            (e) => e && e.origen === 'POS' && e.origenId === saleId
          ) || null;
        };
        txRead.oncomplete = () => resolve();
        txRead.onerror = () => resolve();
      });
    }

    let entryId = existingEntry ? existingEntry.id : null;

    // Crear/actualizar encabezado del asiento
    await new Promise((resolve) => {
      const txWrite = finDb.transaction(['journalEntries'], 'readwrite');
      const storeWrite = txWrite.objectStore('journalEntries');

      if (existingEntry) {
        // Alinear con Finanzas: usar "fecha" y mantener "date" para compatibilidad
        existingEntry.fecha = sale.date;
        existingEntry.date = sale.date;
        existingEntry.descripcion = descripcion;
        existingEntry.tipoMovimiento = tipoMovimiento;
        existingEntry.evento = evento;
        existingEntry.origen = 'POS';
        existingEntry.origenId = saleId;
        existingEntry.totalDebe = totalsDebe;
        existingEntry.totalHaber = totalsHaber;
        storeWrite.put(existingEntry);
      } else {
        const entry = {
          fecha: sale.date,   // campo que Finanzas espera
          date: sale.date,    // compatibilidad con índices previos
          descripcion,
          tipoMovimiento,
          evento,
          origen: 'POS',
          origenId: saleId,
          totalDebe: totalsDebe,
          totalHaber: totalsHaber
        };
        const reqAdd = storeWrite.add(entry);
        reqAdd.onsuccess = (ev) => {
          entryId = ev.target.result;
        };
      }

      txWrite.oncomplete = () => {
        if (!entryId && existingEntry && existingEntry.id != null) {
          entryId = existingEntry.id;
        }
        resolve();
      };
      txWrite.onerror = (e) => {
        console.error('Error guardando asiento automático desde POS', e && e.target && e.target.error);
        resolve();
      };
    });

    if (!entryId) {
      console.error('No se pudo determinar entryId para asiento automático POS');
      return;
    }

    // Borrar líneas anteriores de este asiento (para evitar duplicados)
    await new Promise((resolve) => {
      const txDel = finDb.transaction(['journalLines'], 'readwrite');
      const storeDel = txDel.objectStore('journalLines');
      const reqLines = storeDel.getAll();
      reqLines.onsuccess = () => {
        const lines = reqLines.result || [];
        lines
          .filter((l) => String(l.entryId) === String(entryId) || String(l.idEntry) === String(entryId))
          .forEach((l) => {
            try {
              storeDel.delete(l.id);
            } catch (err) {
              console.error('Error borrando línea contable POS existente', err);
            }
          });
      };
      txDel.oncomplete = () => resolve();
      txDel.onerror = () => resolve();
    });

    // Crear nuevas líneas (ingreso + costo de venta si aplica)
    await new Promise((resolve) => {
      const txLines = finDb.transaction(['journalLines'], 'readwrite');
      const storeLines = txLines.objectStore('journalLines');

      const addLine = (data) => {
        try {
          // Guardamos ambos campos: idEntry (lo que Finanzas espera) y entryId (compatibilidad)
          storeLines.add(Object.assign({ idEntry: entryId, entryId }, data));
        } catch (err) {
          console.error('Error guardando línea contable POS', err);
        }
      };

      if (!sale.isReturn) {
        // Venta normal:
        // Ingreso:
        //   DEBE: Caja/Banco/Clientes
        //   HABER: 4100 Ingresos por ventas Arcano 33
        addLine({ accountCode: cashAccount, debe: amount, haber: 0 });
        addLine({ accountCode: '4100', debe: 0, haber: amount });

        // Costo de venta (si hay costo disponible):
        //   DEBE: 5100 Costo de ventas Arcano 33
        //   HABER: 1500 Inventario producto terminado A33
        if (amountCost > 0) {
          addLine({ accountCode: '5100', debe: amountCost, haber: 0 });
          addLine({ accountCode: '1500', debe: 0, haber: amountCost });
        }
      } else {
        // Devolución: asiento inverso
        // Ingreso inverso:
        //   DEBE: 4100
        //   HABER: Caja/Banco/Clientes
        addLine({ accountCode: '4100', debe: amount, haber: 0 });
        addLine({ accountCode: cashAccount, debe: 0, haber: amount });

        // Costo de venta inverso:
        //   DEBE: 1500
        //   HABER: 5100
        if (amountCost > 0) {
          addLine({ accountCode: '1500', debe: amountCost, haber: 0 });
          addLine({ accountCode: '5100', debe: 0, haber: amountCost });
        }
      }

      txLines.oncomplete = () => resolve();
      txLines.onerror = () => resolve();
    });
  } catch (err) {
    console.error('Error general creando/actualizando asiento automático desde POS', err);
  }
}

// Elimina asientos de Finanzas vinculados a una venta del POS (para Undo / eliminar)
async function deleteFinanzasEntriesForSalePOS(saleId) {
  // IMPORTANTE: esta función SIEMPRE debe devolver una Promise
  // para que el POS no se rompa al hacer: Promise.resolve(...).catch(...)
  if (saleId == null || saleId === '' || Number.isNaN(saleId)) return Promise.resolve();

  try {
    await ensureFinanzasDB();
  } catch (e) {
    // Si no se puede abrir finanzasDB, no bloqueamos el borrado de la venta
    return Promise.resolve();
  }

  return new Promise((resolve, reject) => {
    try {
      const txFin = finDb.transaction(['journalEntries', 'journalLines'], 'readwrite');
      const entriesStore = txFin.objectStore('journalEntries');
      const linesStore = txFin.objectStore('journalLines');

      const entriesReq = entriesStore.getAll();
      entriesReq.onsuccess = () => {
        const allEntries = entriesReq.result || [];
        const targets = allEntries.filter(e => e && e.origen === 'POS' && e.origenId === saleId);
        if (!targets.length) {
          // No hay nada que borrar, dejamos que la tx se complete sola
          return;
        }

        const linesReq = linesStore.getAll();
        linesReq.onsuccess = () => {
          const allLines = linesReq.result || [];
          targets.forEach(entry => {
            const relatedLines = allLines.filter(l => String(l.entryId) === String(entry.id) || String(l.idEntry) === String(entry.id));
            relatedLines.forEach(l => {
              try { linesStore.delete(l.id); } catch (err) {
                console.error('Error borrando línea contable POS', err);
              }
            });
            try { entriesStore.delete(entry.id); } catch (err) {
              console.error('Error borrando asiento automático POS', err);
            }
          });
        };
        linesReq.onerror = (e) => {
          console.error('Error leyendo líneas de diario para borrar asientos POS', e.target.error);
        };
      };
      entriesReq.onerror = (e) => {
        console.error('Error leyendo asientos para borrar por venta POS', e.target.error);
      };

      txFin.oncomplete = () => resolve();
      txFin.onerror = (e) => {
        console.error('Error en transacción de borrado de asientos POS', e.target.error);
        reject(e.target.error);
      };
    } catch (err) {
      console.error('Error general al eliminar asientos POS', err);
      resolve();
    }
  });
}

function tx(name, mode='readonly'){ return db.transaction(name, mode).objectStore(name); }
function getAll(name){ return new Promise((res,rej)=>{ const r=tx(name).getAll(); r.onsuccess=()=>res(r.result||[]); r.onerror=()=>rej(r.error); }); }
function put(name, val){ return new Promise((res,rej)=>{ const r=tx(name,'readwrite').put(val); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
function del(name, key){
  // Borrado robusto (especialmente para 'sales'):
  // - Evita TransactionInactiveError (no dejamos una tx abierta esperando promesas externas)
  // - Nunca "resuelve en silencio" si no pudo borrar
  // - Devuelve { ok:true, warnings:[] } cuando aplica
  return new Promise((resolve, reject) => {
    try{
      if (name !== 'sales'){
        const store = tx(name,'readwrite');
        const r = store.delete(key);
        r.onsuccess = ()=>resolve({ok:true, warnings:[]});
        r.onerror = ()=>reject(r.error);
        return;
      }

      // helpers locales
      const idbGet = (storeName, k) => new Promise((res, rej) => {
        try{
          const st = tx(storeName);
          const r = st.get(k);
          r.onsuccess = ()=>res(r.result);
          r.onerror = ()=>rej(r.error);
        }catch(err){ rej(err); }
      });

      const idbDelete = (storeName, k) => new Promise((res, rej) => {
        try{
          const t = db.transaction([storeName], 'readwrite');
          const st = t.objectStore(storeName);
          try{ st.delete(k); } catch (err){ rej(err); return; }
          t.oncomplete = ()=>res();
          t.onerror = (e)=>rej(t.error || e.target?.error || new Error('Error eliminando registro en ' + storeName));
          t.onabort = (e)=>rej(t.error || e.target?.error || new Error('Transacción abortada eliminando registro en ' + storeName));
        }catch(err){ rej(err); }
      });

      (async ()=>{
        const warnings = [];

        // 1) Traer la venta (fuera de cualquier tx de borrado)
        const sale = await idbGet('sales', key);

        if (!sale){
          // Si no existe, intentamos borrar de todas formas (por si el key es string/number mismatch),
          // y reportamos que ya estaba ausente.
          try{
            await idbDelete('sales', key);
          }catch(err){
            throw err;
          }
          return resolve({ok:true, warnings: ['La venta no se encontró (posible ya estaba eliminada).']});
        }

        // 2) Borrar la venta primero (objetivo principal). Si falla, no hacemos side-effects.
        await idbDelete('sales', key);

        // 2.1) Verificación rápida (mejor error que "parece que borró")
        try{
          const still = await idbGet('sales', key);
          if (still){
            throw new Error('La venta no se pudo eliminar (el registro sigue existiendo).');
          }
        }catch(verErr){
          // Si falla la verificación por lectura, no bloqueamos: solo advertimos.
          console.warn('No se pudo verificar el borrado de la venta', verErr);
        }

        // 3) Side-effects (no bloquean el borrado): revertir inventario central + borrar asientos en Finanzas
        try{
          applyFinishedFromSalePOS(sale, -1);
        }catch(e){
          console.error('Error revertiendo inventario central al eliminar venta', e);
          warnings.push('No se pudo revertir inventario central (la venta sí se eliminó).');
        }

        // Revertir consumo de vasos (FIFO) si esta venta/cortesía fue por vaso
        try{
          await revertCupConsumptionFromSalePOS(sale);
        }catch(e){
          console.error('Error revertiendo vasos al eliminar venta', e);
          warnings.push('No se pudieron revertir vasos de sangría (la venta sí se eliminó).');
        }

        try{
          const saleId = (sale.id != null) ? sale.id : key;
          await Promise.resolve(deleteFinanzasEntriesForSalePOS(saleId));
        }catch(e){
          console.error('Error eliminando asientos contables vinculados a la venta', e);
          warnings.push('No se pudieron eliminar asientos en Finanzas (la venta sí se eliminó).');
        }

        resolve({ok:true, warnings});
      })().catch(err=>{
        console.error('Error en del("sales")', err);
        reject(err);
      });
    }catch(err){
      console.error('Error general en del()', err);
      reject(err);
    }
  });
}


async function setMeta(key, value){ 
  return put('meta', {id:key, value});
}
async function getMeta(key){ 
  const all = await getAll('meta');
  const row = all.find(x=>x.id===key);
  return row ? row.value : null;
}

const LAST_GROUP_KEY = 'a33_pos_lastGroupName';
const HIDDEN_GROUPS_KEY = 'a33_pos_hiddenGroups';

function getLastGroupName() {
  try {
    return localStorage.getItem(LAST_GROUP_KEY) || '';
  } catch (e) {
    return '';
  }
}

function setLastGroupName(name) {
  try {
    localStorage.setItem(LAST_GROUP_KEY, name || '');
  } catch (e) {
    console.warn('No se pudo guardar último grupo usado', e);
  }
}

function getHiddenGroups() {
  try {
    const raw = localStorage.getItem(HIDDEN_GROUPS_KEY);
    if (!raw) return [];
    const arr = JSON.parse(raw);
    return Array.isArray(arr) ? arr : [];
  } catch (e) {
    console.warn('No se pudieron leer grupos ocultos', e);
    return [];
  }
}

function setHiddenGroups(list) {
  try {
    const clean = Array.from(new Set((list || []).filter(Boolean)));
    localStorage.setItem(HIDDEN_GROUPS_KEY, JSON.stringify(clean));
  } catch (e) {
    console.warn('No se pudieron guardar grupos ocultos', e);
  }
}

// --- Caja Chica: helpers y denominaciones
const NIO_DENOMS = [1,5,10,20,50,100,200,500,1000];
const USD_DENOMS = [1,5,10,20,50,100];

function normalizePettySection(section){
  const nio = {};
  const usd = {};

  NIO_DENOMS.forEach(d=>{
    const k = String(d);
    const v = section && section.nio && section.nio[k];
    const num = Number(v);
    nio[k] = (!Number.isFinite(num) || num < 0) ? 0 : num;
  });

  USD_DENOMS.forEach(d=>{
    const k = String(d);
    const v = section && section.usd && section.usd[k];
    const num = Number(v);
    usd[k] = (!Number.isFinite(num) || num < 0) ? 0 : num;
  });

  const totalNio = NIO_DENOMS.reduce((sum,d)=> sum + d * (nio[String(d)]||0), 0);
  const totalUsd = USD_DENOMS.reduce((sum,d)=> sum + d * (usd[String(d)]||0), 0);

  return {
    nio,
    usd,
    totalNio,
    totalUsd,
    savedAt: section && section.savedAt ? section.savedAt : null
  };
}

async function getPettyCash(eventId){
  if (eventId == null) return null;
  if (!db) await openDB();

  return new Promise((resolve, reject)=>{
    try{
      const store = tx('pettyCash','readonly');
      const req = store.get(eventId);
      req.onsuccess = ()=>{
        let pc = req.result;
        if (!pc){
          pc = {
            eventId,
            initial: normalizePettySection(null),
            movements: [],
            finalCount: null
          };
        } else {
          pc.initial = normalizePettySection(pc.initial);
          if (!Array.isArray(pc.movements)) pc.movements = [];
          pc.finalCount = pc.finalCount ? normalizePettySection(pc.finalCount) : null;
        }
        resolve(pc);
      };
      req.onerror = ()=>reject(req.error);
    }catch(err){
      console.error('Error getPettyCash', err);
      resolve({
        eventId,
        initial: normalizePettySection(null),
        movements: [],
        finalCount: null
      });
    }
  });
}

async function savePettyCash(pc){
  if (!pc || pc.eventId == null) return;
  if (!db) await openDB();

  return new Promise((resolve, reject)=>{
    try{
      const store = tx('pettyCash','readwrite');
      const cleaned = {
        eventId: pc.eventId,
        initial: pc.initial ? normalizePettySection(pc.initial) : normalizePettySection(null),
        movements: Array.isArray(pc.movements) ? pc.movements.slice() : [],
        finalCount: pc.finalCount ? normalizePettySection(pc.finalCount) : null
      };
      const req = store.put(cleaned);
      req.onsuccess = ()=>resolve();
      req.onerror = ()=>reject(req.error);
    }catch(err){
      console.error('Error savePettyCash', err);
      resolve();
    }
  });
}

function computePettyCashSummary(pc){
  const base = {
    nio: { initial:0, entradas:0, salidas:0, teorico:0, final:null, diferencia:null },
    usd: { initial:0, entradas:0, salidas:0, teorico:0, final:null, diferencia:null }
  };
  if (!pc) return base;

  const initial = pc.initial ? normalizePettySection(pc.initial) : normalizePettySection(null);
  const finalCount = pc.finalCount ? normalizePettySection(pc.finalCount) : null;

  const res = {
    nio: {
      initial: initial.totalNio || 0,
      entradas: 0,
      salidas: 0,
      teorico: 0,
      final: finalCount ? (finalCount.totalNio || 0) : null,
      diferencia: null
    },
    usd: {
      initial: initial.totalUsd || 0,
      entradas: 0,
      salidas: 0,
      teorico: 0,
      final: finalCount ? (finalCount.totalUsd || 0) : null,
      diferencia: null
    }
  };

  if (Array.isArray(pc.movements)){
    for (const m of pc.movements){
      if (!m || typeof m.amount === 'undefined') continue;
      const amt = Number(m.amount) || 0;
      if (!amt) continue;

      const isNio = m.currency === 'NIO';
      const isUsd = m.currency === 'USD';
      if (!isNio && !isUsd) continue;

      const target = isNio ? res.nio : res.usd;
      if (m.type === 'entrada') target.entradas += amt;
      else if (m.type === 'salida') target.salidas += amt;
    }
  }

  res.nio.teorico = res.nio.initial + res.nio.entradas - res.nio.salidas;
  res.usd.teorico = res.usd.initial + res.usd.entradas - res.usd.salidas;

  if (res.nio.final != null){
    res.nio.diferencia = res.nio.final - res.nio.teorico;
  }
  if (res.usd.final != null){
    res.usd.diferencia = res.usd.final - res.usd.teorico;
  }

  return res;
}

// Normalizar nombres
function normName(s){ return (s||'').toString().normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase().trim(); }

const RECETAS_KEY = 'arcano33_recetas_v1';

const STORAGE_KEY_INVENTARIO = 'arcano33_inventario';

function invParseNumberPOS(value){
  const n = parseFloat(String(value).replace(',', '.'));
  return Number.isNaN(n) ? 0 : n;
}
function invCentralDefaultPOS(){
  return {
    liquids: {},
    bottles: {},
    finished: {
      pulso: { stock: 0 },
      media: { stock: 0 },
      djeba: { stock: 0 },
      litro: { stock: 0 },
      galon: { stock: 0 },
    },
  };
}
function invCentralLoadPOS(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY_INVENTARIO);
    let data = raw ? JSON.parse(raw) : null;
    if (!data || typeof data !== 'object') data = invCentralDefaultPOS();
    if (!data.liquids) data.liquids = {};
    if (!data.bottles) data.bottles = {};
    if (!data.finished) data.finished = {};
    ['pulso','media','djeba','litro','galon'].forEach((id)=>{
      if (!data.finished[id]) data.finished[id] = { stock: 0 };
      const info = data.finished[id];
      if (typeof info.stock !== 'number') info.stock = invParseNumberPOS(info.stock||0);
    });
    return data;
  }catch(e){
    console.warn('Error leyendo inventario central', e);
    return invCentralDefaultPOS();
  }
}
function invCentralSavePOS(inv){
  try{
    localStorage.setItem(STORAGE_KEY_INVENTARIO, JSON.stringify(inv));
  }catch(e){
    console.warn('Error guardando inventario central', e);
  }
}
function mapProductNameToFinishedId(name){
  const n = (name||'').toString().toLowerCase();
  if (n.includes('pulso') && n.includes('250')) return 'pulso';
  if (n.includes('media') && n.includes('375')) return 'media';
  if (n.includes('djeba') && n.includes('750')) return 'djeba';
  if (n.includes('litro') && n.includes('1000')) return 'litro';
  if (n.includes('gal') && (n.includes('3800') || n.includes('galon') || n.includes('galón'))) return 'galon';
  return null;
}
function applyFinishedFromSalePOS(sale, direction){
  try{
    const dir = direction === -1 ? -1 : 1;
    const productName = sale.productName || '';
    const finishedId = mapProductNameToFinishedId(productName);
    if (!finishedId) return;
    const q = typeof sale.qty === 'number' ? sale.qty : parseFloat(sale.qty||'0');
    const qty = Number.isNaN(q) ? 0 : q;
    if (!qty) return;
    const delta = -dir * qty; // dir=+1: registrar venta/devolución; dir=-1: revertir
    const inv = invCentralLoadPOS();
    if (!inv.finished) inv.finished = {};
    if (!inv.finished[finishedId]) inv.finished[finishedId] = { stock: 0 };
    inv.finished[finishedId].stock = invParseNumberPOS(inv.finished[finishedId].stock) + delta;
    invCentralSavePOS(inv);
  }catch(e){
    console.error('Error ajustando inventario central desde venta', e);
  }
}
async function renderCentralFinishedPOS(){
  const tbody = document.querySelector('#tbl-inv-central tbody');
  if (!tbody) return;
  tbody.innerHTML = '';
  const inv = invCentralLoadPOS();
  const defs = [
    { id:'pulso', label:'Pulso 250 ml' },
    { id:'media', label:'Media 375 ml' },
    { id:'djeba', label:'Djeba 750 ml' },
    { id:'litro', label:'Litro 1000 ml' },
    { id:'galon', label:'Galón 3800 ml' },
  ];
  defs.forEach(d=>{
    const info = (inv.finished && inv.finished[d.id]) || { stock: 0 };
    const stock = invParseNumberPOS(info.stock);
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${d.label}</td><td>${stock}</td>`;
    tbody.appendChild(tr);
  });
}


function leerCostosPresentacion() {
  try {
    const raw = localStorage.getItem(RECETAS_KEY);
    if (!raw) return null;
    const data = JSON.parse(raw);
    if (data && data.costosPresentacion) {
      return data.costosPresentacion;
    }
    return null;
  } catch (e) {
    console.warn('No se pudieron leer los costos de presentación desde la Calculadora:', e);
    return null;
  }
}

function mapProductNameToPresId(name) {
  const n = normName(name);
  if (!n) return null;
  if (n.includes('pulso')) return 'pulso';
  if (n.includes('media')) return 'media';
  if (n.includes('djeba')) return 'djeba';
  if (n.includes('litro')) return 'litro';
  if (n.includes('galon')) return 'galon';
  if (n.includes('galón')) return 'galon';
  return null;
}

function getCostoUnitarioProducto(productName) {
  const costos = leerCostosPresentacion();
  if (!costos) return 0;
  const presId = mapProductNameToPresId(productName);
  if (!presId) return 0;
  const info = costos[presId];
  if (!info) return 0;
  const val = typeof info.costoUnidad === 'number' ? info.costoUnidad : 0;
  return val > 0 ? val : 0;
}

// Defaults (SKUs Arcano 33)
const SEED = [
  // "Vaso" aquí es una PORCIÓN vendible (Venta por vaso), no un producto del selector.
  {name:'Vaso', price:100, manageStock:false, active:true, internalType:'cup_portion'},
  {name:'Pulso 250ml', price:120, manageStock:true, active:true},
  {name:'Media 375ml', price:150, manageStock:true, active:true},
  {name:'Djeba 750ml', price:300, manageStock:true, active:true},
  {name:'Litro 1000ml', price:330, manageStock:true, active:true},
  {name:'Galón 3800ml', price:900, manageStock:true, active:true},
];
const DEFAULT_EVENTS = [{name:'General'}];

async function seedMissingDefaults(force=false){
  const list = await getAll('products');
  const names = new Set(list.map(p=>normName(p.name)));
  for (const s of SEED){
    const n = normName(s.name);
    if (force || !names.has(n)){
      const existing = list.find(p=>normName(p.name)===n);
      if (existing){
        existing.active = true;
        if (!existing.price || existing.price <= 0) existing.price = s.price;
        if (typeof existing.manageStock === 'undefined') existing.manageStock = s.manageStock;
        if (s.internalType) existing.internalType = s.internalType;
        await put('products', existing);
      } else {
        await put('products', {...s});
      }
    }
  }
}

// UI helpers
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));
function fmt(n){ return (n||0).toLocaleString('es-NI', {minimumFractionDigits:2, maximumFractionDigits:2}); }
function toast(msg){ const t=$('#toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 1800); }

function humanizeError(err){
  if (!err) return 'Error desconocido.';
  if (typeof err === 'string') return err;
  const name = err.name || '';
  const msg = err.message || String(err);

  if (name === 'TransactionInactiveError') return 'La transacción de la base de datos se cerró antes de tiempo. Recarga el POS y vuelve a intentar.';
  if (name === 'QuotaExceededError') return 'El navegador se quedó sin espacio para guardar datos (QuotaExceeded). Libera espacio o prueba otro navegador.';
  if (name === 'InvalidStateError') return 'El navegador no permitió la operación en este estado (InvalidState). Cierra otras pestañas del POS y recarga.';
  if (name === 'NotFoundError') return 'No se encontró el registro/almacén en la base de datos (NotFound).';
  if (name === 'DataError') return 'Dato inválido para la base de datos (DataError).';

  return msg;
}


function setOfflineBar(){ const ob=$('#offlineBar'); if (!ob) return; ob.style.display = navigator.onLine?'none':'block'; }
window.addEventListener('online', setOfflineBar);
window.addEventListener('offline', setOfflineBar);

// Enable/disable selling block depending on current event
async function updateSellEnabled(){
  const current = await getMeta('currentEventId');
  const evs = await getAll('events');
  const cur = evs.find(e=>e.id===current);
  const enabled = !!(current && cur && !cur.closedAt);
  const chips = $$('#product-chips .chip');
  chips.forEach(c=> c.classList.toggle('disabled', !enabled));
  $('#no-active-note').style.display = enabled ? 'none' : 'block';

  // Bloque Venta por vaso: habilitar/inhabilitar según evento activo
  const cupBlock = document.getElementById('cup-block');
  if (cupBlock){
    cupBlock.classList.toggle('disabled', !enabled);
    cupBlock.querySelectorAll('input, button, select, textarea').forEach(el=>{
      el.disabled = !enabled;
    });
  }

  try{ await refreshCupBlock(); }catch(e){}
}

// Ensure defaults
async function ensureDefaults(){
  let products = await getAll('products');
  if (!products.length){
    for (const p of SEED) await put('products', p);
  } else {
    for (const p of products){
      let changed = false;
      if (typeof p.active === 'undefined'){ p.active = true; changed = true; }
      if (typeof p.manageStock === 'undefined'){ p.manageStock = true; changed = true; }
      if (changed) await put('products', p);
    }
  }
  products = await getAll('products');
  if (products.length < 5) await seedMissingDefaults(true);
  else await seedMissingDefaults(false);

  const events = await getAll('events');
  if (!events.length){ for (const ev of DEFAULT_EVENTS) await put('events', {...ev, createdAt:new Date().toISOString()}); }
  const hasKey = (await getAll('meta')).some(m=>m.id==='currentEventId');
  if (!hasKey){
    const evs = await getAll('events');
    if (evs.length) await setMeta('currentEventId', evs[0].id);
  }
}

// Productos
async function renderProductos(){
  const list = await getAll('products');
  const wrap = $('#productos-list');
  if (!wrap) return;
  wrap.innerHTML = '';
  if (!list.length){
    const p = document.createElement('div'); p.className = 'warn'; p.textContent = 'No hay productos. Agrega los de Arcano 33 abajo.'; wrap.appendChild(p);
  }
  for (const p of list) {
    const row = document.createElement('div');
    row.className = 'card';
    row.innerHTML = `
      <div class="row">
        <input data-id="${p.id}" class="p-name" value="${p.name}">
        <div class="row">
          <input data-id="${p.id}" class="p-price" type="number" inputmode="decimal" step="0.01" value="${p.price}">
          <label class="flag"><input type="checkbox" class="p-active" data-id="${p.id}" ${p.active===false?'':'checked'}> Activo</label>
          <label class="flag"><input type="checkbox" class="p-manage" data-id="${p.id}" ${p.manageStock===false?'':'checked'}> Inventario</label>
          <button data-id="${p.id}" class="btn-danger btn-del">Eliminar</button>
        </div>
      </div>
    `;
    wrap.appendChild(row);
  }
  await renderProductChips();
}

// Productos internos/virtuales del POS que NO deben aparecer en selector ni inventario.
// Nota: "Vaso" aquí representa porciones de sangría (Venta por vaso), no un producto vendible del selector.
async function getHiddenProductIdsPOS(){
  const hidden = new Set();
  try{
    const vaso = await getVasoProductPOS();
    if (vaso && vaso.id != null) hidden.add(vaso.id);
  }catch(e){}
  return hidden;
}

// Chips de productos (todos los activos)
async function renderProductChips(){
  const chips = $('#product-chips'); if (!chips) return;
  chips.innerHTML='';
  const hiddenIds = await getHiddenProductIdsPOS();
  let list = (await getAll('products')).filter(p=>p.active!==false && !hiddenIds.has(p.id));

  // Orden con prioridad de Arcano 33
  const priority = ['pulso','media','djeba','litro','galon','galón','galon 3800','galón 3800'];
  list.sort((a,b)=>{
    const ia = priority.findIndex(x=>normName(a.name).includes(x)); 
    const ib = priority.findIndex(x=>normName(b.name).includes(x));
    const pa = ia===-1?999:ia; const pb = ib===-1?999:ib;
    if (pa!==pb) return pa-pb;
    return a.name.localeCompare(b.name, 'es');
  });

  const current = await getMeta('currentEventId');
  const evs = await getAll('events');
  const cur = evs.find(e=>e.id===current);
  const enabled = !!(current && cur && !cur.closedAt);

  const sel = $('#sale-product');
  const selectedId = parseInt((sel && sel.value) ? sel.value : (list[0]?.id || 0), 10);

  for (const p of list){
    const c = document.createElement('button');
    c.className = 'chip';
    if (!enabled) c.classList.add('disabled');
    c.textContent = p.name;
    c.dataset.id = p.id;
    if (p.id === selectedId) c.classList.add('active');
    c.onclick = async()=>{
      if (!enabled) return;
      const prev = parseInt(sel.value||'0',10);
      sel.value = p.id;
      const same = prev === p.id;
      if (same) { $('#sale-qty').value = Math.max(1, parseFloat($('#sale-qty').value||'1')) + 1; }
      else { $('#sale-qty').value = 1; }
      const pr = (await getAll('products')).find(x=>x.id===p.id);
      if (pr) $('#sale-price').value = pr.price;
      $$('.chip').forEach(x=>x.classList.remove('active')); c.classList.add('active');
      await refreshSaleStockLabel();
      recomputeTotal();
    };
    chips.appendChild(c);
  }

  if (list.length===0){
    const warn = document.createElement('div');
    warn.className = 'warn';
    warn.textContent = 'No hay productos activos. Activa productos en la pestaña Productos o Inventario.';
    chips.appendChild(warn);
  }
}

// Delegación de eventos para Productos
document.addEventListener('change', async (e)=>{
  if (e.target.classList.contains('p-name') || e.target.classList.contains('p-price') || e.target.classList.contains('p-manage') || e.target.classList.contains('p-active')){
    const id = parseInt(e.target.dataset.id||'0',10);
    if (!id) return;
    const all = await getAll('products');
    const cur = all.find(px=>px.id===id); if (!cur) return;
    if (e.target.classList.contains('p-name')) cur.name = e.target.value.trim();
    if (e.target.classList.contains('p-price')) cur.price = parseFloat(e.target.value||'0');
    if (e.target.classList.contains('p-manage')) cur.manageStock = e.target.checked;
    if (e.target.classList.contains('p-active')) cur.active = e.target.checked;
    try{
      await put('products', cur);
      await renderProductos(); 
      await refreshProductSelect(); 
      await renderInventario();
      toast('Producto actualizado');
    }catch(err){
      alert('No se pudo guardar el producto. ¿Nombre duplicado?');
    }
  }
});
document.addEventListener('click', async (e)=>{
  const delBtn = e.target.closest('.btn-del');
  if (delBtn){
    const id = parseInt(delBtn.dataset.id,10);
    if (!confirm('¿Eliminar este producto? Esto no borra ventas pasadas.')) return;
    await del('products', id);
    await renderProductos(); await refreshProductSelect(); await renderInventario();
    toast('Producto eliminado');
  }
});

// Tabs
function setTab(name){
  $$('.tab').forEach(el=> el.style.display='none');
  const target = document.getElementById('tab-'+name);
  if (target) target.style.display='block';
  $$('.tabbar button').forEach(b=>b.classList.remove('active'));
  const btn = document.querySelector(`.tabbar button[data-tab="${name}"]`);
  if (btn) btn.classList.add('active');
  if (name==='resumen') renderSummary();
  if (name==='productos') renderProductos();
  if (name==='eventos') renderEventos();
  if (name==='inventario') renderInventario();
  if (name==='caja') renderCajaChica();
}

// Event UI
function refreshGroupSelectFromEvents(evs) {
  const sel = $('#event-group-select');
  if (!sel) return;

  const hidden = new Set(getHiddenGroups());
  const groups = [];

  for (const ev of evs) {
    const g = (ev.groupName || '').trim();
    if (!g) continue;
    if (hidden.has(g)) continue;
    if (!groups.includes(g)) groups.push(g);
  }

  sel.innerHTML = '';

  const optEmpty = document.createElement('option');
  optEmpty.value = '';
  optEmpty.textContent = '— Selecciona grupo —';
  sel.appendChild(optEmpty);

  for (const g of groups) {
    const o = document.createElement('option');
    o.value = g;
    o.textContent = g;
    sel.appendChild(o);
  }

  const optNew = document.createElement('option');
  optNew.value = '__new__';
  optNew.textContent = '+ Crear nuevo grupo';
  sel.appendChild(optNew);

  const last = getLastGroupName();
  if (last && groups.includes(last)) {
    sel.value = last;
  } else {
    sel.value = '';
  }

  const newInput = $('#event-group-new');
  if (newInput) {
    if (sel.value === '__new__') {
      newInput.style.display = 'inline-block';
    } else {
      newInput.style.display = 'none';
      newInput.value = '';
    }
  }
}

async function refreshEventUI(){
  const evs = await getAll('events');
  refreshGroupSelectFromEvents(evs);
  const sel = $('#sale-event');
  const current = await getMeta('currentEventId');

  sel.innerHTML = '<option value="">— Selecciona evento —</option>';
  for (const ev of evs) {
    const opt = document.createElement('option'); opt.value = ev.id; 
    opt.textContent = ev.name + (ev.closedAt ? ' (cerrado)' : '');
    sel.appendChild(opt);
  }
  if (current) sel.value = current;
  else sel.value = '';

  const status = $('#event-status');
  const cur = evs.find(e=> current && e.id == current);

  // Mantener por defecto el último Evento Maestro (grupo) trabajado.
  // Si el evento activo tiene grupo, lo tomamos como "último" automáticamente.
  try{
    const gCur = (cur && cur.groupName) ? String(cur.groupName).trim() : '';
    if (gCur){
      const hidden = new Set(getHiddenGroups());
      if (!hidden.has(gCur)){
        setLastGroupName(gCur);
        const gs = $('#event-group-select');
        if (gs && Array.from(gs.options).some(o=>o.value===gCur)){
          gs.value = gCur;
        }
      }
    }
  }catch(e){
    console.warn('No se pudo sincronizar grupo desde el evento activo', e);
  }
  if (cur && cur.closedAt) {
    status.style.display='block';
    status.textContent = `Evento cerrado el ${new Date(cur.closedAt).toLocaleString()}. Puedes reabrirlo o crear/activar otro.`;
  } else { status.style.display='none'; }
  $('#btn-reopen-event').style.display = (cur && cur.closedAt) ? 'inline-block' : 'none';

  const invSel = $('#inv-event');
  if (invSel){
    invSel.innerHTML='';
    for (const ev of evs){
      const o = document.createElement('option'); o.value = ev.id; o.textContent = ev.name + (ev.closedAt?' (cerrado)':''); invSel.appendChild(o);
    }
    if (current) invSel.value = current;
    else if (evs.length) invSel.value = evs[0].id;
  }

  await updateSellEnabled();
  await renderProductChips();
}

// Product select + stock label
async function refreshProductSelect(){
  const hiddenIds = await getHiddenProductIdsPOS();
  const all = await getAll('products');
  const list = all.filter(p => !hiddenIds.has(p.id));
  const sel = $('#sale-product');
  if (!sel) return;
  sel.innerHTML = '';
  for (const p of list) {
    const opt = document.createElement('option');
    opt.value = p.id;
    opt.textContent = `${p.name} (C${fmt(p.price)})${p.active===false?' [inactivo]':''}`;
    sel.appendChild(opt);
  }
  const first = list[0] || all[0];
  if (first){ 
    sel.value = first.id; 
    $('#sale-price').value = first.price; 
  }
  await renderProductChips();
  const selId = parseInt(sel.value||'0',10);
  document.querySelectorAll('#product-chips .chip').forEach(x=>{
    if (parseInt(x.dataset.id,10)===selId) x.classList.add('active');
  });
  await refreshSaleStockLabel();
  recomputeTotal();
}

async function refreshSaleStockLabel(){
  const curId = await getMeta('currentEventId');
  const prodId = parseInt($('#sale-product').value||'0',10);
  const products = await getAll('products');
  const p = products.find(pp=>pp.id===prodId);
  if (!p || p.manageStock===false || !curId) { $('#sale-stock').textContent='—'; return; }
  const st = await computeStock(parseInt(curId,10), prodId);
  $('#sale-stock').textContent = st;
}

// Inventory logic
async function getInventoryEntries(eventId){ const all = await getAll('inventory'); return all.filter(i=>i.eventId===eventId); }
async function getInventoryInit(eventId, productId){ const list = (await getInventoryEntries(eventId)).filter(i=>i.productId===productId && i.type==='init'); return list.length ? list.sort((a,b)=> (a.id-b.id))[list.length-1] : null; }
async function setInitialStock(eventId, productId, qty){ let init = await getInventoryInit(eventId, productId); if (init){ init.qty = qty; init.time = new Date().toISOString(); await put('inventory', init); } else { await put('inventory', {eventId, productId, type:'init', qty, notes:'Inicial', time:new Date().toISOString()}); } }
async function addRestock(eventId, productId, qty){ if (qty<=0) throw new Error('Reposición debe ser > 0'); await put('inventory', {eventId, productId, type:'restock', qty, notes:'Reposición', time:new Date().toISOString()}); }
async function addAdjust(eventId, productId, qty, notes){ if (!qty) throw new Error('Ajuste no puede ser 0'); await put('inventory', {eventId, productId, type:'adjust', qty, notes: notes||'Ajuste', time:new Date().toISOString()}); }
async function computeStock(eventId, productId){ const inv = await getInventoryEntries(eventId); const ledger = inv.filter(i=>i.productId===productId).reduce((a,b)=>a+(b.qty||0),0); const sales = (await getAll('sales')).filter(s=>s.eventId===eventId && s.productId===productId).reduce((a,b)=>a+(b.qty||0),0); return ledger - sales; }

// --- Venta por vaso (fraccionamiento de galones) ---
const ML_PER_GALON = 3800;

function safeInt(val, def){
  const n = parseInt(val, 10);
  return Number.isFinite(n) ? n : def;
}

function sanitizeFractionBatches(raw){
  const arr = Array.isArray(raw) ? raw : [];
  return arr.map(b=>{
    const y = safeInt(b && b.yieldCupsPerGallon, 22);
    const gallons = safeInt(b && b.gallons, 0);
    const mlPerCup = (b && typeof b.mlPerCup === 'number' && isFinite(b.mlPerCup) && b.mlPerCup > 0)
      ? b.mlPerCup
      : (ML_PER_GALON / Math.max(1, y));
    const cupsCreated = safeInt(b && b.cupsCreated, gallons * y);
    const cupsRemaining = safeInt(b && b.cupsRemaining, cupsCreated);
    return {
      batchId: (b && b.batchId ? String(b.batchId) : '') || ('fb-' + Math.random().toString(36).slice(2)),
      timestamp: (b && b.timestamp ? String(b.timestamp) : new Date().toISOString()),
      gallons,
      yieldCupsPerGallon: y,
      cupsCreated,
      cupsRemaining,
      mlPerCup,
      note: (b && b.note ? String(b.note) : '')
    };
  });
}

function isCupSaleRecord(sale){
  if (!sale) return false;
  if (sale.vaso === true) return true;
  if (Array.isArray(sale.fifoBreakdown) && sale.fifoBreakdown.length) return true;
  return false;
}

async function getEventByIdPOS(eventId){
  const evs = await getAll('events');
  return evs.find(e => e.id === eventId) || null;
}

async function getVasoProductPOS(){
  const prods = await getAll('products');
  // Prioridad: producto marcado como interno para "Venta por vaso"
  return prods.find(p => p && p.internalType === 'cup_portion')
    || prods.find(p => normName(p.name) === 'vaso')
    || null;
}

function fmtMl(value){
  const n = Number(value || 0);
  if (!Number.isFinite(n)) return '0';
  const r = Math.round(n * 10) / 10;
  if (Math.abs(r - Math.round(r)) < 1e-9) return String(Math.round(r));
  return r.toFixed(1);
}

function computeCupStatsFromEvent(ev, allSales){
  const batches = sanitizeFractionBatches(ev && ev.fractionBatches);
  batches.sort((a,b)=> (a.timestamp||'').localeCompare(b.timestamp||''));

  const cupsAvailable = batches.reduce((a,b)=> a + safeInt(b.cupsRemaining, 0), 0);
  const gallonsFractionedTotal = batches.reduce((a,b)=> a + safeInt(b.gallons, 0), 0);
  const cupsCreatedTotal = batches.reduce((a,b)=> a + safeInt(b.cupsCreated, 0), 0);

  let soldPaid = 0;
  let courtesy = 0;

  (allSales || []).forEach(s=>{
    if (!s || !ev || s.eventId !== ev.id) return;
    if (!isCupSaleRecord(s)) return;
    const q = Number(s.qty || 0);
    const qty = Number.isFinite(q) ? q : 0;
    if (s.courtesy || s.isCourtesy) courtesy += Math.abs(qty);
    else soldPaid += Math.abs(qty);
  });

  const remnantMl = batches.reduce((a,b)=> a + (safeInt(b.cupsRemaining, 0) * (Number(b.mlPerCup) || 0)), 0);

  return { batches, cupsAvailable, gallonsFractionedTotal, cupsCreatedTotal, soldPaid, courtesy, remnantMl };
}

async function refreshCupBlock(){
  const evId = await getMeta('currentEventId');
  const block = document.getElementById('cup-block');
  if (!block) return;

  const setText = (id, val) => {
    const el = document.getElementById(id);
    if (el) el.textContent = val;
  };

  if (!evId){
    setText('cup-available','0');
    setText('cup-gallons','0');
    setText('cup-created','0');
    setText('cup-sold','0');
    setText('cup-courtesy','0');
    setText('cup-remaining','0');
    setText('cup-remnant','0');
    return;
  }

  const ev = await getEventByIdPOS(evId);
  const allSales = await getAll('sales');
  const stats = computeCupStatsFromEvent(ev, allSales);

  setText('cup-available', String(stats.cupsAvailable));
  setText('cup-gallons', String(stats.gallonsFractionedTotal));
  setText('cup-created', String(stats.cupsCreatedTotal));
  setText('cup-sold', String(stats.soldPaid));
  setText('cup-courtesy', String(stats.courtesy));
  setText('cup-remaining', String(stats.cupsAvailable));
  setText('cup-remnant', fmtMl(stats.remnantMl));

  // Default de precio por vaso (si está vacío o en 0)
  try{
    const inp = document.getElementById('cup-price');
    if (inp){
      const cur = parseFloat(inp.value || '0');
      if (!cur){
        const vasoProd = await getVasoProductPOS();
        if (vasoProd && Number(vasoProd.price) > 0) inp.value = vasoProd.price;
      }
    }
  }catch(e){}
}

async function fractionGallonsToCupsPOS(){
  const evId = await getMeta('currentEventId');
  if (!evId){ alert('Selecciona un evento'); return; }

  const ev = await getEventByIdPOS(evId);
  if (!ev){ alert('Evento no encontrado'); return; }
  if (ev.closedAt){ alert('Este evento está cerrado. Reábrelo o activa otro.'); return; }

  const gallonsToFraction = safeInt(document.getElementById('cup-fraction-gallons')?.value, 0);
  const yieldCupsPerGallon = safeInt(document.getElementById('cup-yield')?.value, 22);

  if (!(gallonsToFraction >= 1)) { alert('Galones a fraccionar debe ser un entero >= 1'); return; }
  if (!(yieldCupsPerGallon >= 1)) { alert('Vasos por galón debe ser un entero >= 1'); return; }

  // Validar inventario de Galón (producto terminado) usando el sistema existente
  const products = await getAll('products');
  const galProd = products.find(p => mapProductNameToFinishedId(p.name) === 'galon') || null;
  if (!galProd){
    alert('No encontré el producto "Galón 3800ml" en Productos. Restaura productos base o créalo.');
    return;
  }

  const stockEvent = await computeStock(evId, galProd.id);
  if (stockEvent < gallonsToFraction){
    alert(`Inventario insuficiente de Galón para este evento. Disponible: ${stockEvent}. Intentas fraccionar: ${gallonsToFraction}.`);
    return;
  }

  // Descontar inventario por evento (ledger) y central (producto terminado)
  try{
    await addAdjust(evId, galProd.id, -gallonsToFraction, `Fraccionado a vasos (${yieldCupsPerGallon} vasos/galón)`);
  }catch(e){
    console.error('No se pudo registrar ajuste de inventario por evento al fraccionar', e);
  }

  try{
    applyFinishedFromSalePOS({ productName: galProd.name, qty: gallonsToFraction }, +1);
  }catch(e){
    console.error('No se pudo actualizar inventario central al fraccionar', e);
  }

  const batchId = 'fb-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,7);
  const cupsCreated = gallonsToFraction * yieldCupsPerGallon;
  const mlPerCup = ML_PER_GALON / yieldCupsPerGallon;

  const batches = sanitizeFractionBatches(ev.fractionBatches);
  batches.push({
    batchId,
    timestamp: new Date().toISOString(),
    gallons: gallonsToFraction,
    yieldCupsPerGallon,
    cupsCreated,
    cupsRemaining: cupsCreated,
    mlPerCup,
    note: ''
  });

  ev.fractionBatches = batches;
  await put('events', ev);

  await renderInventario();
  await refreshSaleStockLabel();
  await refreshCupBlock();
  toast(`Fraccionados ${gallonsToFraction} galón(es) a ${yieldCupsPerGallon} vasos/galón → +${cupsCreated} vasos`);
}

function fifoTakeCups(batches, qty){
  let remaining = qty;
  const breakdown = [];
  const ordered = [...batches].sort((a,b)=> (a.timestamp||'').localeCompare(b.timestamp||''));
  for (const b of ordered){
    if (remaining <= 0) break;
    const avail = safeInt(b.cupsRemaining, 0);
    if (avail <= 0) continue;
    const take = Math.min(avail, remaining);
    if (take > 0){
      b.cupsRemaining = avail - take;
      breakdown.push({ batchId: b.batchId, cupsTaken: take, mlPerCup: b.mlPerCup });
      remaining -= take;
    }
  }
  return { ok: remaining === 0, breakdown };
}

async function sellCupsPOS(isCourtesy){
  const evId = await getMeta('currentEventId');
  if (!evId){ alert('Selecciona un evento'); return; }

  const ev = await getEventByIdPOS(evId);
  if (!ev){ alert('Evento no encontrado'); return; }
  if (ev.closedAt){ alert('Este evento está cerrado. Reábrelo o activa otro.'); return; }

  const qty = safeInt(document.getElementById('cup-qty')?.value, 0);
  if (!(qty >= 1)) { alert('Cantidad de vasos debe ser un entero >= 1'); return; }

  const allSales = await getAll('sales');
  const stats = computeCupStatsFromEvent(ev, allSales);
  if (stats.cupsAvailable < qty){
    alert('No hay vasos disponibles. Fraccioná un galón.');
    return;
  }

  const batches = stats.batches; // sanitized
  const taken = fifoTakeCups(batches, qty);
  if (!taken.ok){
    alert('No hay vasos suficientes. Fraccioná un galón.');
    return;
  }

  ev.fractionBatches = batches;
  await put('events', ev);

  const date = document.getElementById('sale-date')?.value || '';
  if (!date){ alert('Selecciona una fecha'); return; }

  const payment = document.getElementById('sale-payment')?.value || 'efectivo';
  const customer = (payment === 'credito') ? (document.getElementById('sale-customer')?.value || '').trim() : '';
  if (payment === 'credito' && !customer){ alert('Ingresa el nombre del cliente (crédito)'); return; }

  let vasoProd = await getVasoProductPOS();
  // Si alguien borró el producto interno "Vaso", lo recreamos (sin exponerlo en el selector)
  if (!vasoProd){
    try{
      const newId = await put('products', {name:'Vaso', price:100, manageStock:false, active:false, internalType:'cup_portion'});
      vasoProd = {id: newId, price:100, manageStock:false, active:false, internalType:'cup_portion'};
    }catch(e){}
  }
  const productId = vasoProd ? vasoProd.id : 0;

  const unitPrice = isCourtesy ? 0 : parseFloat(document.getElementById('cup-price')?.value || '0');
  if (!isCourtesy && !(unitPrice > 0)){
    alert('Ingresa un precio por vaso (> 0) o usa "Registrar cortesía".');
    return;
  }

  const productName = isCourtesy ? 'Vaso (Cortesía)' : 'Vaso';
  const total = isCourtesy ? 0 : (unitPrice * qty);

  const now = new Date();
  const time = now.toTimeString().slice(0,5);

  const saleRecord = {
    date,
    time,
    eventId: evId,
    eventName: ev.name || 'General',
    productId,
    productName,
    unitPrice,
    qty,
    discount: 0,
    payment,
    courtesy: !!isCourtesy,
    isCourtesy: !!isCourtesy,
    isReturn: false,
    customer,
    courtesyTo: isCourtesy ? ((document.getElementById('sale-courtesy-to')?.value || '').trim()) : '',
    total,
    notes: isCourtesy ? 'Cortesía por vaso' : 'Venta por vaso',
    costPerUnit: 0,
    lineCost: 0,
    lineProfit: total,
    vaso: true,
    fifoBreakdown: taken.breakdown
  };

  const saleId = await put('sales', saleRecord);
  saleRecord.id = saleId;

  try{
    await createJournalEntryForSalePOS(saleRecord);
  }catch(e){
    console.error('No se pudo generar asiento contable para venta por vaso', e);
  }

  const qtyInp = document.getElementById('cup-qty');
  if (qtyInp) qtyInp.value = 1;

  await renderDay();
  await renderSummary();
  await refreshSaleStockLabel();
  await renderInventario();
  await refreshCupBlock();
  toast(isCourtesy ? 'Cortesía registrada' : 'Venta por vaso agregada');
}

async function revertCupConsumptionFromSalePOS(sale){
  if (!sale || !isCupSaleRecord(sale)) return;

  const evId = sale.eventId;
  if (!evId) return;

  const ev = await getEventByIdPOS(evId);
  if (!ev) return;

  const batches = sanitizeFractionBatches(ev.fractionBatches);

  const qAbs = Math.abs(Number(sale.qty || 0)) || 0;
  const breakdown = Array.isArray(sale.fifoBreakdown) ? sale.fifoBreakdown : [];

  if (breakdown.length){
    for (const item of breakdown){
      const bid = (item.batchId || '').toString();
      const taken = safeInt(item.cupsTaken, 0);
      if (!bid || !taken) continue;

      const b = batches.find(x => String(x.batchId) === bid);
      if (b){
        b.cupsRemaining = safeInt(b.cupsRemaining, 0) + taken;
      } else {
        const mlPerCup = (typeof item.mlPerCup === 'number' && isFinite(item.mlPerCup) && item.mlPerCup > 0)
          ? item.mlPerCup
          : (ML_PER_GALON / 22);
        const yieldGuess = Math.max(1, Math.round(ML_PER_GALON / mlPerCup));
        batches.push({
          batchId: 'adj-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,7),
          timestamp: new Date().toISOString(),
          gallons: 0,
          yieldCupsPerGallon: yieldGuess,
          cupsCreated: 0,
          cupsRemaining: taken,
          mlPerCup,
          note: 'Ajuste por eliminación (batch faltante)'
        });
      }
    }
  } else if (qAbs) {
    const oldest = batches.sort((a,b)=> (a.timestamp||'').localeCompare(b.timestamp||''))[0];
    if (oldest){
      oldest.cupsRemaining = safeInt(oldest.cupsRemaining, 0) + qAbs;
    } else {
      batches.push({
        batchId: 'adj-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,7),
        timestamp: new Date().toISOString(),
        gallons: 0,
        yieldCupsPerGallon: 22,
        cupsCreated: 0,
        cupsRemaining: qAbs,
        mlPerCup: ML_PER_GALON / 22,
        note: 'Ajuste por eliminación (sin batches)'
      });
    }
  }

  ev.fractionBatches = batches;
  await put('events', ev);
  await refreshCupBlock();
}


// Importar inventario desde Control de Lotes
async function importFromLoteToInventory(){
  const evSel = $('#inv-event');
  let evId = evSel && evSel.value ? parseInt(evSel.value,10) : null;
  if (!evId){
    alert('Primero selecciona un evento.');
    return;
  }
  let lotes = [];
  try {
    const raw = localStorage.getItem('arcano33_lotes');
    if (raw) lotes = JSON.parse(raw) || [];
    if (!Array.isArray(lotes)) lotes = [];
  } catch (e) {
    alert('No se pudo leer la información de lotes guardada en el navegador.');
    return;
  }
  if (!lotes.length){
    alert('No hay lotes registrados en el Control de Lotes.');
    return;
  }
  const listaCodigos = lotes
    .map(l => (l.codigo || '').trim())
    .filter(c => c)
    .join(', ');
  const codigo = prompt('Escribe el CÓDIGO del lote que quieres asignar a este evento (códigos disponibles: ' + (listaCodigos || 'ninguno') + '):');
  if (!codigo) return;
  const codigoNorm = (codigo || '').toString().toLowerCase().trim();
  const lote = lotes.find(l => ((l.codigo || '').toString().toLowerCase().trim() === codigoNorm));
  if (!lote){
    alert('No se encontró un lote con ese código.');
    return;
  }
  const map = [
    { field: 'pulso', name: 'Pulso 250ml' },
    { field: 'media', name: 'Media 375ml' },
    { field: 'djeba', name: 'Djeba 750ml' },
    { field: 'litro', name: 'Litro 1000ml' },
    { field: 'galon', name: 'Galón 3800ml' }
  ];
  const products = await getAll('products');
  const norm = s => (s||'').toString().normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase().trim();
  let total = 0;
  for (const m of map){
    const rawQty = (lote[m.field] ?? '0').toString();
    const qty = parseInt(rawQty, 10);
    if (!(qty > 0)) continue;
    const prod = products.find(p => norm(p.name) === norm(m.name));
    if (!prod) continue;
    await addRestock(evId, prod.id, qty);
    total += qty;
  }
  await renderInventario();
  await refreshSaleStockLabel();
  alert('Se agregó inventario desde el lote "' + (lote.codigo || '') + '" al evento seleccionado.');
}

// Inventario UI
async function renderInventario(){
  const tbody = $('#tbl-inv tbody');
  if (!tbody) return;
  tbody.innerHTML='';

  const evSel = $('#inv-event');
  let evId = evSel && evSel.value ? parseInt(evSel.value,10) : null;
  if (!evId){
    const evs = await getAll('events');
    if (evs.length) evId = evs[0].id;
    if (evSel && evId) invSel.value = evId;
  }
  if (!evId){
    const tr = document.createElement('tr'); tr.innerHTML = '<td colspan="8">No hay eventos. Crea uno en la pestaña Vender.</td>'; tbody.appendChild(tr); return;
  }

  const prods = await getAll('products');
  const hiddenIds = await getHiddenProductIdsPOS();
  for (const p of prods){
    if (hiddenIds.has(p.id)) continue;
    const st = await computeStock(evId, p.id);
    const init = await getInventoryInit(evId, p.id);
    const disabled = (p.manageStock===false) ? 'disabled' : '';
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${p.name}</td>
      <td><input type="checkbox" class="inv-active" data-id="${p.id}" ${p.active===false?'':'checked'}></td>
      <td><input type="checkbox" class="inv-manage" data-id="${p.id}" ${p.manageStock===false?'':'checked'}></td>
      <td><input class="inv-inicial" data-id="${p.id}" type="number" inputmode="numeric" step="1" value="${init?init.qty:0}" ${disabled}></td>
      <td><input class="inv-repo" data-id="${p.id}" type="number" inputmode="numeric" step="1" placeholder="+" ${disabled}></td>
      <td><input class="inv-ajuste" data-id="${p.id}" type="number" inputmode="numeric" step="1" placeholder="+/-" ${disabled}></td>
      <td><span class="stockpill ${st<=0?'low':''}">${st}</span></td>
      <td class="actions">
        <button class="act-guardar-inicial" data-id="${p.id}" ${disabled}>Guardar inicial</button>
        <button class="act-reponer" data-id="${p.id}" ${disabled}>Reponer</button>
        <button class="act-ajustar" data-id="${p.id}" ${disabled}>Ajustar</button>
      </td>
    `;
    if (p.manageStock===false) tr.classList.add('dim');
    tbody.appendChild(tr);
  }
}

// Inventario: listeners
document.addEventListener('click', async (e)=>{
  if (e.target.classList.contains('act-guardar-inicial')){
    const pid = parseInt(e.target.dataset.id,10);
    const evId = parseInt($('#inv-event').value||'0',10);
    const tr = e.target.closest('tr');
    const qty = parseInt(tr.querySelector('.inv-inicial').value||'0',10);
    await setInitialStock(evId, pid, isNaN(qty)?0:qty);
    await renderInventario(); await refreshSaleStockLabel();
    toast('Inicial guardado');
  }
  if (e.target.classList.contains('act-reponer')){
    const pid = parseInt(e.target.dataset.id,10);
    const evId = parseInt($('#inv-event').value||'0',10);
    const tr = e.target.closest('tr');
    const qty = parseInt(tr.querySelector('.inv-repo').value||'0',10);
    if (!(qty>0)) { alert('Ingresa una reposición > 0'); return; }
    await addRestock(evId, pid, qty);
    tr.querySelector('.inv-repo').value='';
    await renderInventario(); await refreshSaleStockLabel();
    toast('Reposición agregada');
  }
  if (e.target.classList.contains('act-ajustar')){
    const pid = parseInt(e.target.dataset.id,10);
    const evId = parseInt($('#inv-event').value||'0',10);
    const tr = e.target.closest('tr');
    const qty = parseInt(tr.querySelector('.inv-ajuste').value||'0',10);
    if (!qty) { alert('Ingresa un ajuste (positivo o negativo)'); return; }
    await addAdjust(evId, pid, qty, 'Ajuste manual');
    tr.querySelector('.inv-ajuste').value='';
    await renderInventario(); await refreshSaleStockLabel();
    toast('Ajuste registrado');
  }
});

document.addEventListener('change', async (e)=>{
  if (e.target.classList.contains('inv-manage') || e.target.classList.contains('inv-active')){
    const id = parseInt(e.target.dataset.id||'0',10);
    const all = await getAll('products');
    const cur = all.find(px=>px.id===id); if (!cur) return;
    if (e.target.classList.contains('inv-manage')) cur.manageStock = e.target.checked;
    if (e.target.classList.contains('inv-active')) cur.active = e.target.checked;
    await put('products', cur);
    await renderInventario(); await renderProductChips(); await refreshProductSelect();
  }
});

// Day list filtered by current event
async function renderDay(){
  try {
    const d = $('#sale-date').value;
    const curId = await getMeta('currentEventId');
    const tbody = $('#tbl-day tbody');
    if (!tbody) return;
    tbody.innerHTML = '';
    if (!curId){ 
      $('#day-total').textContent = fmt(0); 
      return; 
    }
    const allSales = await getAll('sales');
    const filtered = allSales.filter(s => s.eventId === curId && s.date === d);
    let total = 0;
    filtered.sort((a,b)=> (a.id||0) - (b.id||0));
    for (const s of filtered){
      total += Number(s.total || 0);
      const payClass = s.payment==='efectivo'
        ? 'pay-ef'
        : (s.payment==='transferencia' ? 'pay-tr' : 'pay-cr');
      const payTxt = s.payment==='efectivo'
        ? 'Efec'
        : (s.payment==='transferencia' ? 'Trans' : 'Cred');
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${s.time||''}</td>
        <td>${s.productName}</td>
        <td>${s.qty}</td>
        <td>${fmt(s.unitPrice)}</td>
        <td>${fmt(s.discount||0)}</td>
        <td>${fmt(s.total)}</td>
        <td><span class="tag ${payClass}">${payTxt}</span></td>
        <td>${s.courtesy?'✓':''}</td>
        <td>${s.isReturn?'✓':''}</td>
        <td>${s.customer||''}</td>
        <td>${s.courtesyTo||''}</td>
        <td><button data-id="${s.id}" title="Eliminar venta" class="btn-danger btn-mini del-sale">Eliminar</button></td>`;
      tbody.appendChild(tr);
    }
    $('#day-total').textContent = fmt(total);
  } catch (e) {
    console.error('Error en renderDay', e);
    const tbody = $('#tbl-day tbody');
    if (tbody) tbody.innerHTML = '';
    $('#day-total').textContent = fmt(0);
  }
}

// Summary (extendido con costo y utilidad)
async function renderSummary(){
  const sales = await getAll('sales');
  const events = await getAll('events');
  let grand = 0;
  let grandCost = 0;
  let grandProfit = 0;

  const byDay=new Map(); 
  const byProd=new Map(); 
  const byPay=new Map(); 
  const byEvent=new Map();

  for (const s of sales){
    const total = Number(s.total || 0);
    grand += total;

    byDay.set(s.date,(byDay.get(s.date)||0)+total);
    byProd.set(s.productName,(byProd.get(s.productName)||0)+total);
    byPay.set(s.payment||'efectivo',(byPay.get(s.payment||'efectivo')||0)+total);
    byEvent.set(s.eventName||'General',(byEvent.get(s.eventName||'General')||0)+total);

    // Costo y utilidad aproximada (solo ventas/no cortesías)
    if (!s.courtesy) {
      let lineCost = 0;
      if (typeof s.lineCost === 'number') {
        lineCost = Number(s.lineCost || 0);
      } else if (typeof s.costPerUnit === 'number') {
        const qty = Number(s.qty || 0);
        lineCost = s.costPerUnit * qty;
      }

      let lineProfit = 0;
      if (typeof s.lineProfit === 'number') {
        lineProfit = Number(s.lineProfit || 0);
      } else {
        lineProfit = total - lineCost;
      }

      grandCost += lineCost;
      grandProfit += lineProfit;
    }
  }

  // Acumular también lo archivado por evento en grand / tablas de resumen
  for (const ev of events){
    if (ev.archive && ev.archive.totals){
      const t = ev.archive.totals;
      grand += (t.grand||0);
      byEvent.set(ev.name,(byEvent.get(ev.name)||0)+(t.grand||0));
      if (t.byPay){ for (const k of Object.keys(t.byPay)){ byPay.set(k,(byPay.get(k)||0)+(t.byPay[k]||0)); } }
      if (t.byProduct){ for (const k of Object.keys(t.byProduct)){ byProd.set(k,(byProd.get(k)||0)+(t.byProduct[k]||0)); } }
      if (t.byDay){ for (const k of Object.keys(t.byDay)){ byDay.set(k,(byDay.get(k)||0)+(t.byDay[k]||0)); } }
      // Nota: por ahora no tenemos costo/utilidad archivados, así que grandCost/grandProfit reflejan ventas vivas.
    }
  }

  // Total vendido
  $('#grand-total').textContent = fmt(grand);

  // Crear/actualizar bloque extra para costo y utilidad si no existe en el HTML
  const totalSpan = document.getElementById('grand-total');
  if (totalSpan) {
    let extraBlock = document.getElementById('grand-extra-block');
    if (!extraBlock) {
      const card = totalSpan.closest('.card') || totalSpan.parentElement || document.getElementById('tab-resumen') || document.body;
      extraBlock = document.createElement('div');
      extraBlock.id = 'grand-extra-block';
      if (card) card.appendChild(extraBlock);
    }
    extraBlock.innerHTML = `
      <p>Costo estimado de producto: C$ <span id="grand-cost">${fmt(grandCost)}</span></p>
      <p>Utilidad bruta aproximada: C$ <span id="grand-profit">${fmt(grandProfit)}</span></p>
    `;
  }

  const tbE=$('#tbl-por-evento tbody'); tbE.innerHTML='';
  [...byEvent.entries()].sort((a,b)=>a[0].localeCompare(b[0])).forEach(([k,v])=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${k}</td><td>${fmt(v)}</td>`; tbE.appendChild(tr); });

  const tbD=$('#tbl-por-dia tbody'); tbD.innerHTML='';
  [...byDay.entries()].sort((a,b)=>a[0].localeCompare(b[0])).forEach(([k,v])=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${k}</td><td>${fmt(v)}</td>`; tbD.appendChild(tr); });

  const tbP=$('#tbl-por-prod tbody'); tbP.innerHTML='';
  [...byProd.entries()].sort((a,b)=>a[0].localeCompare(b[0])).forEach(([k,v])=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${k}</td><td>${fmt(v)}</td>`; tbP.appendChild(tr); });

  const tbPay=$('#tbl-por-pago tbody'); tbPay.innerHTML='';
  [...byPay.entries()].sort((a,b)=>a[0].localeCompare(b[0])).forEach(([k,v])=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${k}</td><td>${fmt(v)}</td>`; tbPay.appendChild(tr); });
}

// CSV helpers
function downloadCSV(name, rows){
  const csv = rows.map(r=>r.map(x=>{
    if (x==null) return '';
    const s = String(x);
    if (/[",\n]/.test(s)) { return '"' + s.replace(/"/g,'""') + '"'; }
    else { return s; }
  }).join(',')).join('\n');
  const blob = new Blob([csv],{type:'text/csv;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download=name; a.click();
  setTimeout(()=>URL.revokeObjectURL(url),2000);


function downloadExcel(filename, sheetName, rows){
  if (typeof XLSX === 'undefined'){
    alert('No se pudo generar el archivo de Excel (librería XLSX no cargada). Revisa tu conexión a internet.');
    return;
  }
  const ws = XLSX.utils.aoa_to_sheet(rows);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, sheetName || 'Hoja1');
  XLSX.writeFile(wb, filename);
}

}

async function generateInventoryCSV(eventId){
  const prods = await getAll('products');
  const inv = await getInventoryEntries(eventId);
  const sales = await getAll('sales');
  const rows = [['producto','manejar','inicial','reposiciones','ajustes','vendido','stock_actual']];
  for (const p of prods){
    const inits = inv.filter(i=>i.productId===p.id && i.type==='init').reduce((a,b)=>a+(b.qty||0),0);
    const repo = inv.filter(i=>i.productId===p.id && i.type==='restock').reduce((a,b)=>a+(b.qty||0),0);
    const adj = inv.filter(i=>i.productId===p.id && i.type==='adjust').reduce((a,b)=>a+(b.qty||0),0);
    const sold = sales.filter(s=>s.eventId===eventId && s.productId===p.id).reduce((a,b)=>a+(b.qty||0),0);
    const stock = inits + repo + adj - sold;
    rows.push([p.name, p.manageStock!==false?1:0, inits, repo, adj, sold, stock]);
  }
  downloadExcel('inventario_evento.xlsx', 'Inventario', rows);
}

// Eventos UI
async function renderEventos(){
  const filtro = $('#filtro-eventos').value || 'todos';
  const groupSelect = $('#filtro-grupo');
  const tbody = $('#tbl-eventos tbody');
  tbody.innerHTML = '';

  const events = await getAll('events');
  const sales = await getAll('sales');

  // Construir opciones de filtro de grupo
  if (groupSelect){
    const current = groupSelect.value || '';
    const grupos = [];
    let haySinGrupo = false;
    for (const ev of events){
      const g = (ev.groupName || '').trim();
      if (g){
        if (!grupos.includes(g)) grupos.push(g);
      } else {
        haySinGrupo = true;
      }
    }
    grupos.sort((a,b)=>a.localeCompare(b,'es-NI'));
    let opts = '<option value="">Grupos: Todos</option>';
    if (haySinGrupo){
      opts += '<option value="__sin_grupo__">[Sin grupo]</option>';
    }
    for (const g of grupos){
      const esc = g.replace(/"/g,'&quot;');
      opts += `<option value="${esc}">${esc}</option>`;
    }
    groupSelect.innerHTML = opts;
    if (current && Array.from(groupSelect.options).some(o=>o.value===current)){
      groupSelect.value = current;
    }
  }

  const filtroGrupo = groupSelect ? (groupSelect.value || '') : '';

  const rows = events.map(ev=>{
    const tot = sales.filter(s=>s.eventId===ev.id).reduce((a,b)=>a+(b.total||0),0);
    return {...ev, _totalCached: tot};
  }).filter(ev=>{
    if (filtro==='abiertos' && ev.closedAt) return false;
    if (filtro==='cerrados' && !ev.closedAt) return false;

    if (filtroGrupo){
      const g = (ev.groupName || '').trim();
      if (filtroGrupo === '__sin_grupo__'){
        if (g) return false;
      } else {
        if (g !== filtroGrupo) return false;
      }
    }
    return true;
  }).sort((a,b)=>{
    const ad = a.createdAt||''; const bd = b.createdAt||'';
    return (bd>ad) ? 1 : -1;
  });

  for (const ev of rows){
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${ev.name}</td>
      <td>${(ev.groupName||'')}</td>
      <td>${ev.closedAt?'<span class="tag closed">cerrado</span>':'<span class="tag open">abierto</span>'}</td>
      <td>${ev.createdAt?new Date(ev.createdAt).toLocaleString():''}</td>
      <td>${ev.closedAt?new Date(ev.closedAt).toLocaleString():''}</td>
      <td>C$ ${fmt(ev._totalCached)}</td>
      <td class="actions">
        <button class="act-ver" data-id="${ev.id}">VER</button>
        <button class="act-activar" data-id="${ev.id}">Activar</button>
        ${ev.closedAt?'<button class="act-reabrir" data-id="'+ev.id+'">Reabrir</button>':'<button class="act-cerrar" data-id="'+ev.id+'">Cerrar</button>'}
        <button class="act-corte" data-id="${ev.id}">CSV Corte</button>
        <button class="act-ventas" data-id="${ev.id}">CSV Ventas</button>
        <button class="act-inv" data-id="${ev.id}">CSV Inv</button>
        <button class="act-eliminar btn-danger" data-id="${ev.id}">Eliminar</button>
      </td>
    `;
    tbody.appendChild(tr);
  }
}
// Modal VER: rellenar
function showEventView(show){ $('#event-view').style.display = show ? 'flex' : 'none'; }
async function openEventView(eventId){
  const events = await getAll('events');
  const ev = events.find(e=>e.id===eventId);
  if (!ev) return;
  const sales = (await getAll('sales')).filter(s=>s.eventId===eventId);

  $('#ev-title').textContent = `Evento: ${ev.name}`;
  $('#ev-meta').innerHTML = `<div><b>Estado:</b> ${ev.closedAt?'Cerrado':'Abierto'}</div>
  <div><b>Creado:</b> ${ev.createdAt?new Date(ev.createdAt).toLocaleString():'—'}</div>
  <div><b>Cerrado:</b> ${ev.closedAt?new Date(ev.closedAt).toLocaleString():'—'}</div>
  <div><b># Ventas:</b> ${sales.length}</div>`;

  const total = sales.reduce((a,b)=>a+b.total,0);

  // cálculo de costo de producto usando el costo unitario por presentación
  let costoProductos = 0;
  for (const s of sales) {
    const unitCost = getCostoUnitarioProducto(s.productName);
    const absQty = Math.abs(s.qty || 0);
    const qtyParaCosto = s.isReturn ? -absQty : absQty;
    if (unitCost > 0 && qtyParaCosto !== 0) {
      costoProductos += unitCost * qtyParaCosto;
    }
  }
  const utilidadBruta = total - costoProductos;

  const byPay = sales.reduce((m,s)=>{ m[s.payment]=(m[s.payment]||0)+s.total; return m; },{});
  $('#ev-totals').innerHTML = `<div><b>Total vendido:</b> C$ ${fmt(total)}</div>
  <div><b>Costo estimado de producto:</b> C$ ${fmt(costoProductos)}</div>
  <div><b>Utilidad bruta aprox.:</b> C$ ${fmt(utilidadBruta)}</div>
  <div><b>Efectivo:</b> C$ ${fmt(byPay.efectivo||0)}</div>
  <div><b>Transferencia:</b> C$ ${fmt(byPay.transferencia||0)}</div>
  <div><b>Crédito:</b> C$ ${fmt(byPay.credito||0)}</div>`;

  const byDay = Array.from((()=>{ const m = new Map(); for (const s of sales){ m.set(s.date, (m.get(s.date)||0)+s.total); } return m; })().entries()).sort((a,b)=>a[0].localeCompare(b[0]));
  const tbd = $('#ev-byday tbody'); tbd.innerHTML=''; byDay.forEach(([k,v])=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${k}</td><td>${fmt(v)}</td>`; tbd.appendChild(tr); });

  const byProd = Array.from((()=>{ const m = new Map(); for (const s of sales){ m.set(s.productName, (m.get(s.productName)||0)+s.total); } return m; })().entries()).sort((a,b)=>a[0].localeCompare(b[0]));
  const tbp = $('#ev-byprod tbody'); tbp.innerHTML=''; byProd.forEach(([k,v])=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${k}</td><td>${fmt(v)}</td>`; tbp.appendChild(tr); });

  const tb = $('#ev-sales tbody'); tb.innerHTML='';
  sales.sort((a,b)=>a.id-b.id).forEach(s=>{
    const tr=document.createElement('tr'); tr.innerHTML = `<td>${s.id}</td><td>${s.date}</td><td>${s.time||''}</td><td>${s.productName}</td><td>${s.qty}</td><td>${fmt(s.unitPrice)}</td><td>${fmt(s.discount||0)}</td><td>${fmt(s.total)}</td><td>${s.payment}</td><td>${s.courtesy?'✓':''}</td><td>${s.isReturn?'✓':''}</td><td>${s.customer||''}</td><td>${s.courtesyTo||''}</td><td>${s.notes||''}</td>`;
    tb.appendChild(tr);
  });

  showEventView(true);
}

// CSV ventas/corte
async function exportEventSalesCSV(eventId){
  const events = await getAll('events');
  const ev = events.find(e=>e.id===eventId);
  const sales = (await getAll('sales')).filter(s=>s.eventId===eventId);
  const rows = [['id','fecha','hora','producto','cant','PU','desc_C$','total','pago','cortesia','devolucion','cliente','cortesia_a','notas']];
  for (const s of sales){
    rows.push([s.id, s.date, s.time||'', s.productName, s.qty, s.unitPrice, (s.discount||0), s.total, (s.payment||''), s.courtesy?1:0, s.isReturn?1:0, s.customer||'', s.courtesyTo||'', s.notes||'']);
  }
  const safeName = (ev?ev.name:'evento').replace(/[^a-z0-9_\- ]/gi,'_');
  downloadExcel(`ventas_${safeName}.xlsx`, 'Ventas', rows);
}
function buildCorteSummaryRows(eName, sales){
  let efectivo=0, trans=0, credito=0, descuentos=0, cortesiasU=0, cortesiasVal=0, devolU=0, devolVal=0, bruto=0;
  for (const s of sales){
    const absQty = Math.abs(s.qty||0);
    const absTotal = Math.abs(s.total||0);
    bruto += (s.courtesy ? (s.unitPrice*absQty) : (absTotal + (s.discount||0)));
    descuentos += (s.discount||0) * (s.isReturn?-1:1);
    if (s.courtesy){ cortesiasU += absQty; cortesiasVal += (s.unitPrice*absQty); }
    if (s.isReturn){ devolU += absQty; devolVal += absTotal; }
    if (s.payment==='efectivo') efectivo += s.total;
    else if (s.payment==='transferencia') trans += s.total;
    else if (s.payment==='credito'){ credito += s.total; }
  }
  const cobrado = efectivo + trans;
  const neto = cobrado;
  return {efectivo, trans, credito, descuentos, cortesiasU, cortesiasVal, devolU, devolVal, bruto, cobrado, neto};
}
async function generateCorteCSV(eventId){
  const events = await getAll('events');
  const ev = events.find(e=>e.id===eventId);
  if (!ev){ alert('Evento no encontrado'); return; }
  const sales = (await getAll('sales')).filter(s=>s.eventId===eventId);
  const sum = buildCorteSummaryRows(ev.name, sales);
  const rows = [];
  rows.push(['Corte de evento', ev.name]);
  rows.push(['Generado', new Date().toLocaleString()]);
  rows.push([]);
  rows.push(['Resumen de cobros']);
  rows.push(['Efectivo', sum.efectivo.toFixed(2)]);
  rows.push(['Transferencia', sum.trans.toFixed(2)]);
  rows.push(['Crédito', sum.credito.toFixed(2)]);
  rows.push(['Cobrado (sin crédito)', sum.cobrado.toFixed(2)]);
  rows.push([]);
  rows.push(['Ajustes']);
  rows.push(['Descuentos aplicados (C$)', sum.descuentos.toFixed(2)]);
  rows.push(['Cortesías (unid.)', sum.cortesiasU]);
  rows.push(['Cortesías valor ref. (C$)', sum.cortesiasVal.toFixed(2)]);
  rows.push(['Devoluciones (unid.)', sum.devolU]);
  rows.push(['Devoluciones (C$)', sum.devolVal.toFixed(2)]);
  rows.push([]);
  rows.push(['Ventas brutas ref. (aprox.)', sum.bruto.toFixed(2)]);
  rows.push(['Neto cobrado', sum.neto.toFixed(2)]);
  rows.push([]);
  rows.push(['Detalle de ventas']);
  rows.push(['id','fecha','hora','producto','cant','PU','desc_C$','total','pago','cortesia','devolucion','cliente','cortesia_a','notas']);
  for (const s of sales){
    rows.push([s.id, s.date, s.time||'', s.productName, s.qty, s.unitPrice, (s.discount||0), s.total, (s.payment||''), s.courtesy?1:0, s.isReturn?1:0, s.customer||'', s.courtesyTo||'', s.notes||'']);
  }
  const safeName = ev.name.replace(/[^a-z0-9_\- ]/gi,'_');
  downloadExcel(`corte_${safeName}.xlsx`, 'Corte', rows);
}

async function exportEventExcel(eventId){
  if (typeof XLSX === 'undefined'){
    alert('No se pudo generar el archivo de Excel (librería XLSX no cargada). Revisa tu conexión a internet.');
    return;
  }

  const events = await getAll('events');
  const ev = events.find(e=>e.id===eventId);
  if (!ev){
    alert('Evento no encontrado');
    return;
  }

  const allSales = await getAll('sales');
  const sales = allSales.filter(s=>s.eventId===eventId);

  const pc = await getPettyCash(eventId);
  const summary = computePettyCashSummary(pc || null);
  const init = pc && pc.initial ? normalizePettySection(pc.initial) : normalizePettySection(null);
  const fin  = pc && pc.finalCount ? normalizePettySection(pc.finalCount) : normalizePettySection(null);
  const movs = pc && Array.isArray(pc.movements) ? pc.movements.slice() : [];

  // --- Hoja 1: Resumen del evento ---
  const resumenRows = [];
  resumenRows.push(['Evento', ev.name || '']);
  resumenRows.push(['ID', ev.id]);
  resumenRows.push(['Estado', ev.closedAt ? 'Cerrado' : 'Abierto']);
  resumenRows.push(['Creado', ev.createdAt ? new Date(ev.createdAt).toLocaleString() : '']);
  resumenRows.push(['Cerrado', ev.closedAt ? new Date(ev.closedAt).toLocaleString() : '']);
  resumenRows.push([]);

  const totalVentas = sales.reduce((acc,s)=>acc + (s.total || 0), 0);
  resumenRows.push(['Resumen de ventas']);
  resumenRows.push(['Total vendido C$', totalVentas]);

  const byPay = sales.reduce((m,s)=>{
    const pay = s.payment || 'desconocido';
    m[pay] = (m[pay] || 0) + (s.total || 0);
    return m;
  },{});
  resumenRows.push([]);
  resumenRows.push(['Cobros por forma de pago']);
  resumenRows.push(['Efectivo C$', byPay.efectivo || 0]);
  resumenRows.push(['Transferencia C$', byPay.transferencia || 0]);
  resumenRows.push(['Crédito C$', byPay.credito || 0]);

  resumenRows.push([]);
  resumenRows.push(['Caja Chica - C$']);
  resumenRows.push(['Saldo inicial C$', summary.nio.initial]);
  resumenRows.push(['Entradas C$', summary.nio.entradas]);
  resumenRows.push(['Salidas C$', summary.nio.salidas]);
  resumenRows.push(['Saldo teórico C$', summary.nio.teorico]);
  resumenRows.push(['Saldo final contado C$', summary.nio.final != null ? summary.nio.final : '—']);
  resumenRows.push(['Diferencia C$', summary.nio.diferencia != null ? summary.nio.diferencia : '—']);

  resumenRows.push([]);
  resumenRows.push(['Caja Chica - US$']);
  resumenRows.push(['Saldo inicial US$', summary.usd.initial]);
  resumenRows.push(['Entradas US$', summary.usd.entradas]);
  resumenRows.push(['Salidas US$', summary.usd.salidas]);
  resumenRows.push(['Saldo teórico US$', summary.usd.teorico]);
  resumenRows.push(['Saldo final contado US$', summary.usd.final != null ? summary.usd.final : '—']);
  resumenRows.push(['Diferencia US$', summary.usd.diferencia != null ? summary.usd.diferencia : '—']);

  const wb = XLSX.utils.book_new();
  const wsResumen = XLSX.utils.aoa_to_sheet(resumenRows);
  XLSX.utils.book_append_sheet(wb, wsResumen, 'Resumen_Evento');

  // --- Hoja 2: CajaChica_Detalle ---
  const detRows = [];

  // Saldo inicial C$
  detRows.push(['Saldo inicial C$']);
  detRows.push(['Denominación','Cantidad','Subtotal C$']);
  for (const d of NIO_DENOMS){
    const qty = init.nio[String(d)] || 0;
    const sub = d * qty;
    detRows.push([d, qty, sub]);
  }
  detRows.push(['', '', '']);
  detRows.push(['Total inicial C$', '', init.totalNio || 0]);

  detRows.push([]);
  // Saldo inicial US$
  detRows.push(['Saldo inicial US$']);
  detRows.push(['Denominación','Cantidad','Subtotal US$']);
  for (const d of USD_DENOMS){
    const qty = init.usd[String(d)] || 0;
    const sub = d * qty;
    detRows.push([d, qty, sub]);
  }
  detRows.push(['', '', '']);
  detRows.push(['Total inicial US$', '', init.totalUsd || 0]);
  detRows.push(['Fecha/hora saldo inicial', init.savedAt || '']);

  detRows.push([]);
  // Movimientos
  detRows.push(['Movimientos de Caja Chica']);
  detRows.push(['Fecha','Tipo','Moneda','Monto','Descripción']);
  for (const m of movs){
    const tipoText = m.type === 'salida' ? 'Salida' : 'Entrada';
    const monedaText = m.currency === 'USD' ? 'US$' : 'C$';
    detRows.push([m.date || '', tipoText, monedaText, m.amount || 0, m.description || '']);
  }

  detRows.push([]);
  // Arqueo final C$
  detRows.push(['Arqueo final C$']);
  detRows.push(['Denominación','Cantidad','Subtotal C$']);
  for (const d of NIO_DENOMS){
    const qty = fin.nio[String(d)] || 0;
    const sub = d * qty;
    detRows.push([d, qty, sub]);
  }
  detRows.push(['', '', '']);
  detRows.push(['Total final C$', '', fin.totalNio || 0]);

  detRows.push([]);
  // Arqueo final US$
  detRows.push(['Arqueo final US$']);
  detRows.push(['Denominación','Cantidad','Subtotal US$']);
  for (const d of USD_DENOMS){
    const qty = fin.usd[String(d)] || 0;
    const sub = d * qty;
    detRows.push([d, qty, sub]);
  }
  detRows.push(['', '', '']);
  detRows.push(['Total final US$', '', fin.totalUsd || 0]);
  detRows.push(['Fecha/hora arqueo final', fin.savedAt || '']);

  const wsCaja = XLSX.utils.aoa_to_sheet(detRows);
  XLSX.utils.book_append_sheet(wb, wsCaja, 'CajaChica_Detalle');

  // --- Hoja 3 opcional: Ventas_Detalle ---
  const ventasRows = [];
  ventasRows.push(['id','fecha','hora','producto','cantidad','PU_C$','descuento_C$','total_C$','pago','cortesia','devolucion','cliente','cortesia_a','notas']);
  for (const s of sales){
    ventasRows.push([
      s.id,
      s.date || '',
      s.time || '',
      s.productName || '',
      s.qty || 0,
      s.unitPrice || 0,
      s.discount || 0,
      s.total || 0,
      s.payment || '',
      s.courtesy ? 1 : 0,
      s.isReturn ? 1 : 0,
      s.customer || '',
      s.courtesyTo || '',
      s.notes || ''
    ]);
  }
  const wsVentas = XLSX.utils.aoa_to_sheet(ventasRows);
  XLSX.utils.book_append_sheet(wb, wsVentas, 'Ventas_Detalle');

  const safeName = (ev.name || 'evento').replace(/[^a-z0-9_\- ]/gi,'_');
  XLSX.writeFile(wb, `evento_${safeName}.xlsx`);
}

// --- Close / Reopen / Activate / Delete ---
async function closeEvent(eventId){
  const events = await getAll('events');
  const ev = events.find(e=>e.id===eventId);
  if (!ev){ alert('Evento no encontrado'); return; }
  if (ev.closedAt){ alert('Este evento ya está cerrado.'); return; }
  await generateCorteCSV(eventId);
  ev.closedAt = new Date().toISOString();
  await put('events', ev);
  await setMeta('currentEventId', null);
  await refreshEventUI(); await renderEventos(); await renderDay(); await renderSummary();
  toast('Evento cerrado (sin borrar ventas)');
}

async function reopenEvent(eventId){
  const events = await getAll('events');
  const ev = events.find(e=>e.id===eventId);
  if (!ev){ alert('Evento no encontrado'); return; }
  ev.closedAt = null;
  await put('events', ev);
  await setMeta('currentEventId', eventId);
  await refreshEventUI(); await renderEventos();
  toast('Evento reabierto');
}

async function activateEvent(eventId){
  await setMeta('currentEventId', eventId);
  await refreshEventUI();
  await renderDay();
  toast('Evento activado');
}

async function deleteEvent(eventId){
  const events = await getAll('events');
  const ev = events.find(e=>e.id===eventId);
  if (!ev){ alert('Evento no encontrado'); return; }
  const msg = '¿Eliminar evento "'+ev.name+'"? Se borrarán sus ventas e inventario. Esta acción NO se puede deshacer.';
  if (!confirm(msg)) return;
  const t = db.transaction(['sales','events','inventory','meta'],'readwrite');
  await new Promise((res)=>{ const r = t.objectStore('sales').getAll(); r.onsuccess = ()=>{ (r.result||[]).filter(s=>s.eventId===eventId).forEach(s=> t.objectStore('sales').delete(s.id)); res(); }; });
  await new Promise((res)=>{ const r = t.objectStore('inventory').getAll(); r.onsuccess = ()=>{ (r.result||[]).filter(i=>i.eventId===eventId).forEach(i=> t.objectStore('inventory').delete(i.id)); res(); }; });
  t.objectStore('events').delete(eventId);
  const mreq = t.objectStore('meta').get('currentEventId');
  mreq.onsuccess = ()=>{ const cur = mreq.result?.value; if (cur === eventId) t.objectStore('meta').put({id:'currentEventId', value:null}); };
  await new Promise((res,rej)=>{ t.oncomplete=res; t.onerror=()=>rej(t.error); });
  await refreshEventUI(); await renderEventos(); await renderDay(); await renderSummary(); await renderInventario(); await renderProductos();
  toast('Evento eliminado');
}

// Botón Restaurar productos base (A33)
async function restoreSeed(){
  await seedMissingDefaults(true);
  await renderProductos(); await refreshProductSelect(); await renderInventario();
  toast('Productos base restaurados');
}

// Init & bindings
async function init(){
  // Paso 1: abrir base de datos POS
  try{
    await openDB();
  }catch(err){
    alert('No se pudo abrir la base de datos del POS. Revisa permisos de almacenamiento del navegador.');
    console.error('INIT openDB ERROR', err);
    return;
  }

  // Helper para que cada paso falle de forma aislada sin tumbar todo el POS
  const runStep = async (name, fn) => {
    try{
      await fn();
    }catch(err){
      console.error('INIT step error en ' + name, err);
    }
  };

  // Paso 2: defaults y migraciones
  await runStep('ensureDefaults', ensureDefaults);

  // Paso 3: preparar fecha por defecto
  try{
    const dateInput = document.getElementById('sale-date');
    if (dateInput && !dateInput.value){
      const now = new Date();
      const y = now.getFullYear();
      const m = String(now.getMonth()+1).padStart(2,'0');
      const d = String(now.getDate()).padStart(2,'0');
      dateInput.value = `${y}-${m}-${d}`;
    }
  }catch(err){
    console.error('INIT step error al configurar fecha por defecto', err);
  }

  // Paso 4: refrescar vistas principales
  await runStep('refreshEventUI', refreshEventUI);
  await runStep('refreshProductSelect', refreshProductSelect);
  await runStep('renderDay', renderDay);
  await runStep('refreshCupBlock', refreshCupBlock);
  await runStep('renderSummary', renderSummary);
  await runStep('renderProductos', renderProductos);
  await runStep('renderEventos', renderEventos);
  await runStep('renderInventario', renderInventario);
  await runStep('renderCajaChica', renderCajaChica);
  await runStep('updateSellEnabled', updateSellEnabled);

  // Paso 5: barra offline y eventos de Caja Chica
  try{
    setOfflineBar();
  }catch(err){
    console.error('INIT step error en setOfflineBar', err);
  }

  try{
    bindCajaChicaEvents();
  }catch(err){
    console.error('INIT step error en bindCajaChicaEvents', err);
  }

  // Los listeners de la UI principal se mantienen igual
  const tabbar = document.querySelector('.tabbar');
  if (tabbar) {
    tabbar.addEventListener('click', (e)=>{
      const b = e.target.closest('button');
      if (!b) return;
      const tab = b.dataset.tab;
      if (tab) setTab(tab);
    });
  }

  // Vender tab

  $('#sale-event').addEventListener('change', async()=>{ 
    const val = $('#sale-event').value;
    if (val === '') { await setMeta('currentEventId', null); }
    else { await setMeta('currentEventId', parseInt(val,10)); }
    await refreshEventUI(); 
    await refreshSaleStockLabel(); 
    await renderDay();
  });

  const groupSelect = $('#event-group-select');
  const groupNewInput = $('#event-group-new');

  // Helper: recordar el último grupo usado (Evento Maestro)
  function rememberGroup(name){
    const g = (name || '').trim();
    if (g && g !== '__new__'){
      setLastGroupName(g);
    }
  }

  if (groupSelect) {
    groupSelect.addEventListener('change', ()=>{
      const v = (groupSelect.value || '').trim();

      // Persistir selección de grupo para que quede por defecto la próxima vez.
      if (v && v !== '__new__') {
        rememberGroup(v);
      }

      const newInput = $('#event-group-new');
      if (!newInput) return;

      if (v === '__new__') {
        newInput.style.display = 'inline-block';

        // Si el último grupo guardado no está en la lista, úsalo como sugerencia.
        const last = getLastGroupName();
        if (last && !Array.from(groupSelect.options).some(o=>o.value===last)) {
          newInput.value = last;
        }

        newInput.focus();
      } else {
        newInput.style.display = 'none';
        newInput.value = '';
      }
    });
  }

  // Si el usuario escribe un grupo nuevo, también lo recordamos.
  if (groupNewInput) {
    const saveTyped = ()=>{
      const t = (groupNewInput.value || '').trim();
      if (t) setLastGroupName(t);
    };
    groupNewInput.addEventListener('blur', saveTyped);
    groupNewInput.addEventListener('keydown', (ev)=>{
      if (ev.key === 'Enter') {
        ev.preventDefault();
        saveTyped();
      }
    });
  }

  const btnManageGroups = $('#btn-manage-groups');
  if (btnManageGroups) {
    btnManageGroups.addEventListener('click', async ()=>{
      const evs = await getAll('events');
      const hidden = new Set(getHiddenGroups());
      const allGroups = [];
      for (const ev of evs) {
        const g = (ev.groupName || '').trim();
        if (!g) continue;
        if (!allGroups.includes(g)) allGroups.push(g);
      }
      const visible = allGroups.filter(g => !hidden.has(g));
      if (!visible.length) {
        alert('No hay grupos disponibles para gestionar.');
        return;
      }
      const msg = 'Grupos actuales:\n' + visible.map((g,i)=> `${i+1}. ${g}`).join('\n') +
                  '\n\nEscribe el número del grupo que deseas ocultar:';
      const choice = prompt(msg);
      if (!choice) return;
      const idxNum = parseInt(choice, 10);
      if (!idxNum || idxNum < 1 || idxNum > visible.length) {
        alert('Selección no válida');
        return;
      }
      hidden.add(visible[idxNum-1]);
      setHiddenGroups(Array.from(hidden));
      await refreshEventUI();
      alert('Grupo ocultado. Ya no aparecerá para nuevos eventos, pero sigue existiendo en el historial.');
    });
  }
  $('#btn-add-event').addEventListener('click', async()=>{
  const name = ($('#new-event').value || '').trim();
  const groupSelect = $('#event-group-select');
  const groupNew = $('#event-group-new');
  let groupName = '';

  if (groupSelect) {
    const v = groupSelect.value;
    if (v === '__new__') {
      if (groupNew) {
        groupName = (groupNew.value || '').trim();
      }
    } else if (v && v !== '__new__') {
      groupName = v.trim();
    }
  }

  if (!name) {
    alert('Escribe un nombre de evento');
    return;
  }

  const id = await put('events', {name, groupName, createdAt:new Date().toISOString()});
  await setMeta('currentEventId', id);
  $('#new-event').value = '';

  if (groupNew) {
    groupNew.value = '';
    if (groupSelect && groupSelect.value === '__new__') {
      groupSelect.value = groupName || '';
    }
  }

  if (groupName) {
    setLastGroupName(groupName);
  }

  await refreshEventUI();
  await renderEventos();
  await renderInventario();
  await renderDay();
  toast('Evento creado');
});
  $('#btn-close-event').addEventListener('click', async()=>{ const id = parseInt($('#sale-event').value||'0',10); const current = await getMeta('currentEventId'); const useId = id || current; if (!useId) return alert('Selecciona un evento'); await closeEvent(parseInt(useId,10)); });
  $('#btn-reopen-event').addEventListener('click', async()=>{ const val = $('#sale-event').value; const id = parseInt(val||'0',10); if (!id) return alert('Selecciona un evento cerrado'); await reopenEvent(id); });

  $('#sale-product').addEventListener('change', async()=>{ const id = parseInt($('#sale-product').value,10); const p = (await getAll('products')).find(x=>x.id===id); if (p) $('#sale-price').value = p.price; document.querySelectorAll('#product-chips .chip').forEach(x=>x.classList.toggle('active', parseInt(x.dataset.id,10)===id)); await refreshSaleStockLabel(); recomputeTotal(); });
  $('#sale-price').addEventListener('input', recomputeTotal);
  $('#sale-qty').addEventListener('input', recomputeTotal);
  $('#sale-discount').addEventListener('input', recomputeTotal);
  $('#sale-courtesy').addEventListener('change', ()=>{ $('#sale-courtesy-to').disabled = !$('#sale-courtesy').checked; recomputeTotal(); });
  $('#sale-return').addEventListener('change', recomputeTotal);
  $('#sale-payment').addEventListener('change', ()=>{ const isCred = $('#sale-payment').value==='credito'; $('#sale-customer').disabled = !isCred; if (!isCred) $('#sale-customer').value=''; });
  $('#sale-date').addEventListener('change', renderDay);
  $('#btn-add').addEventListener('click', addSale);
  const stickyBtn = $('#btn-add-sticky');
  if (stickyBtn) {
    stickyBtn.addEventListener('click', addSale);
  }

  // Venta por vaso (fraccionamiento de galones)
  const btnFraction = document.getElementById('btn-fraction');
  if (btnFraction) btnFraction.addEventListener('click', fractionGallonsToCupsPOS);

  const btnSellCups = document.getElementById('btn-sell-cups');
  if (btnSellCups) btnSellCups.addEventListener('click', ()=> sellCupsPOS(false));

  const btnCourtesyCups = document.getElementById('btn-courtesy-cups');
  if (btnCourtesyCups) btnCourtesyCups.addEventListener('click', ()=> sellCupsPOS(true));

  // Deshacer última venta del día para el evento activo
  $('#btn-undo').addEventListener('click', async ()=>{
    const curId = await getMeta('currentEventId');
    if (!curId) {
      alert('No hay evento activo.');
      return;
    }
    const d = $('#sale-date').value;
    const allSales = await getAll('sales');
    const filtered = allSales.filter(s => s.eventId === curId && s.date === d);
    if (!filtered.length) {
      alert('No hay ventas para deshacer en este día.');
      return;
    }
    const last = filtered.sort((a,b)=> a.id - b.id)[filtered.length - 1];
    if (!confirm('¿Eliminar la última venta registrada?')) return;
    const delRes = await del('sales', last.id);
    await renderDay();
    await renderSummary();
    await refreshSaleStockLabel();
    await renderInventario();
    if (delRes && delRes.warnings && delRes.warnings.length){
      alert('Venta eliminada, pero con avisos:\n\n- ' + delRes.warnings.join('\n- '));
    }
    toast('Venta eliminada');
  });

  // Eliminar una venta específica desde la tabla
  $('#tbl-day').addEventListener('click', async (e)=>{
    const btn = e.target.closest('button.del-sale');
    if (!btn) return;

    const rawId = btn.dataset.id;
    const id = Number(rawId);

    if (!Number.isFinite(id)){
      alert('No pude identificar la venta a eliminar (id inválido). Recarga el POS y vuelve a intentar.');
      return;
    }

    if (!confirm('¿Eliminar esta venta?')) return;

    const prevText = btn.textContent;
    btn.disabled = true;
    btn.textContent = 'Eliminando…';

    try{
      const delRes = await del('sales', id);

      // Refrescar UI
      try{
        await renderDay();
        await renderSummary();
        await refreshSaleStockLabel();
        await renderInventario();
      }catch(uiErr){
        console.error('Error refrescando UI después de eliminar venta', uiErr);
      }

      if (delRes && delRes.warnings && delRes.warnings.length){
        alert('Venta eliminada, pero con avisos:\n\n- ' + delRes.warnings.join('\n- '));
      }

      toast('Venta eliminada');
    }catch(err){
      console.error('Error eliminando la venta', err);
      alert('No se pudo eliminar la venta.\n\nDetalle: ' + humanizeError(err));
    }finally{
      btn.disabled = false;
      btn.textContent = prevText || 'Eliminar';
    }
  });
  // Stepper
  $('#qty-minus').addEventListener('click', ()=>{ const v = Math.max(1, parseInt($('#sale-qty').value||'1',10) - 1); $('#sale-qty').value = v; recomputeTotal(); });
  $('#qty-plus').addEventListener('click', ()=>{ const v = Math.max(1, parseInt($('#sale-qty').value||'1',10) + 1); $('#sale-qty').value = v; recomputeTotal(); });

  // Productos: agregar + restaurar
  document.getElementById('btn-add-prod').onclick = async()=>{ const name = $('#new-name').value.trim(); const price = parseFloat($('#new-price').value||'0'); if (!name || !(price>0)) return alert('Nombre y precio'); try{ await put('products', {name, price, manageStock:true, active:true}); $('#new-name').value=''; $('#new-price').value=''; await renderProductos(); await refreshProductSelect(); await renderInventario(); toast('Producto agregado'); }catch(err){ alert('No se pudo agregar. ¿Nombre duplicado?'); } };
  document.getElementById('btn-restore-seed').onclick = restoreSeed;

  
async function exportEventosExcel(){
  const events = await getAll('events');
  const sales = await getAll('sales');
  const rows = [['id','evento','grupo','estado','creado','cerrado','total']];

  for (const ev of events){
    const tot = sales.filter(s=>s.eventId===ev.id).reduce((a,b)=>a+(b.total||0),0);
    const estado = ev.closedAt ? 'Cerrado' : 'Abierto';
    rows.push([
      ev.id,
      ev.name || '',
      ev.groupName || '',
      estado,
      ev.createdAt || '',
      ev.closedAt || '',
      tot.toFixed ? tot.toFixed(2) : tot
    ]);
  }

  downloadExcel('eventos.xlsx', 'Eventos', rows);
}

// Eventos tab actions
  $('#filtro-eventos').addEventListener('change', renderEventos);
  const filtroGrupoEl = document.getElementById('filtro-grupo');
  if (filtroGrupoEl){
    filtroGrupoEl.addEventListener('change', renderEventos);
  }
  const cierreBtn = document.getElementById('btn-cierre-total');
  if (cierreBtn){
    cierreBtn.addEventListener('click', computeCierreTotalGrupo);
  }
  const cierreExcelBtn = document.getElementById('btn-cierre-total-excel');
  if (cierreExcelBtn){
    cierreExcelBtn.addEventListener('click', exportCierreTotalGrupoExcel);
  }
  const cierreCajaBtn = document.getElementById('btn-cierre-caja-grupo');
  if (cierreCajaBtn){
    cierreCajaBtn.addEventListener('click', computeCierreCajaChicaGrupo);
  }
  const cierreCajaExcelBtn = document.getElementById('btn-cierre-caja-excel');
  if (cierreCajaExcelBtn){
    cierreCajaExcelBtn.addEventListener('click', exportCierreCajaChicaGrupoExcel);
  }
  $('#btn-exportar-eventos').addEventListener('click', async()=>{
    await exportEventosExcel();
  });
  $('#btn-exportar-evento-excel').addEventListener('click', async()=>{
    const evId = await getMeta('currentEventId');
    if (!evId){
      alert('Debes activar un evento en la pestaña Vender antes de exportar a Excel.');
      return;
    }
    await exportEventExcel(evId);
  });
  $('#tbl-eventos').addEventListener('click', async(e)=>{ const btn = e.target.closest('button'); if (!btn) return; const id = parseInt(btn.dataset.id,10);
    if (btn.classList.contains('act-ver')) await openEventView(id);
    else if (btn.classList.contains('act-activar')) await activateEvent(id);
    else if (btn.classList.contains('act-reabrir')) await reopenEvent(id);
    else if (btn.classList.contains('act-cerrar')) await closeEvent(id);
    else if (btn.classList.contains('act-corte')) await generateCorteCSV(id);
    else if (btn.classList.contains('act-ventas')) await exportEventSalesCSV(id);
    else if (btn.classList.contains('act-inv')) await generateInventoryCSV(id);
    else if (btn.classList.contains('act-eliminar')) await deleteEvent(id);
    await renderEventos(); await renderSummary();
  });

  // Modal close
  document.getElementById('ev-close').onclick = ()=> showEventView(false);
  document.getElementById('event-view').addEventListener('click', (e)=>{ if (e.target.id==='event-view') showEventView(false); });

  // Inventario tab
  $('#inv-event').addEventListener('change', renderInventario);
  $('#btn-inv-ref').addEventListener('click', renderInventario);
  $('#btn-inv-csv').addEventListener('click', async()=>{ const id = parseInt($('#inv-event').value||'0',10); if (!id) return alert('Selecciona un evento'); await generateInventoryCSV(id); });
  const btnFromLote = document.getElementById('btn-inv-from-lote');
  if (btnFromLote) btnFromLote.addEventListener('click', importFromLoteToInventory);

}

// Totales y ventas
function recomputeTotal(){
  const price = parseFloat($('#sale-price').value||'0');
  const qty = Math.max(0, parseFloat($('#sale-qty').value||'0'));
  const discountPerUnit = Math.max(0, parseFloat($('#sale-discount').value||'0'));
  const courtesy = $('#sale-courtesy').checked;
  const isReturn = $('#sale-return').checked;

  // Precio efectivo por unidad luego del descuento fijo
  const effectiveUnit = Math.max(0, price - discountPerUnit);
  let total = effectiveUnit * qty;

  if (courtesy) {
    total = 0;
  }
  if (isReturn) {
    total = -total;
  }

  const t = total.toFixed(2);
  const saleTotalInput = $('#sale-total');
  if (saleTotalInput) {
    saleTotalInput.value = t;
  }
  const stickyEl = $('#sticky-total');
  if (stickyEl) {
    stickyEl.textContent = t;
  }
}

async function addSale(){
  const curId = await getMeta('currentEventId');
  if (!curId){ alert('Selecciona un evento'); return; }
  const date = $('#sale-date').value;
  const productId = parseInt($('#sale-product').value||'0',10);
  const qtyIn = parseFloat($('#sale-qty').value||'0');
  const qty = Math.abs(qtyIn);
  const price = parseFloat($('#sale-price').value||'0');
  const discountPerUnit = Math.max(0, parseFloat($('#sale-discount').value||'0'));
  const payment = $('#sale-payment').value;
  const courtesy = $('#sale-courtesy').checked;
  const isReturn = $('#sale-return').checked;
  const customer = (payment==='credito') ? ($('#sale-customer').value||'').trim() : '';
  const courtesyTo = $('#sale-courtesy-to').value || '';
  const notes = $('#sale-notes').value || '';
  if (!date || !productId || !qty) { alert('Completa fecha, producto y cantidad'); return; }
  if (payment==='credito' && !customer){ alert('Ingresa el nombre del cliente (crédito)'); return; }

  const events = await getAll('events');
  const event = events.find(e=>e.id===curId);
  if (!event || event.closedAt){ alert('Este evento está cerrado. Reábrelo o activa otro.'); return; }

  const products = await getAll('products');
  const prod = products.find(p=>p.id===productId);
  const productName = prod ? prod.name : 'N/D';

  if (prod && prod.manageStock!==false && !isReturn){
    const st = await computeStock(curId, productId);
    if (st < qty){
      const go = confirm(`Stock insuficiente de ${productName}: disponible ${st}, intentas vender ${qty}. ¿Continuar de todos modos?`);
      if (!go) return;
    }
  }

  let subtotal = price * qty;
  let discount = discountPerUnit * qty;
  if (courtesy) {
    discount = 0;
  }
  let total = courtesy ? 0 : Math.max(0, subtotal - discount);
  const finalQty = isReturn ? -qty : qty;
  if (isReturn) total = -total;

  const unitCost = getCostoUnitarioProducto(productName);
  const lineCost = unitCost * finalQty;
  const lineProfit = total - lineCost;

  const eventName = event ? event.name : 'General';
  const now = new Date(); const time = now.toTimeString().slice(0,5);

  // Ajustar inventario central de producto terminado
  try{
    applyFinishedFromSalePOS({ productName, qty: finalQty }, +1);
  }catch(e){
    console.error('No se pudo actualizar inventario central desde venta', e);
  }

  const saleRecord = {
    date,
    time,
    eventId:curId,
    eventName,
    productId,
    productName,
    unitPrice:price,
    qty:finalQty,
    discount,
    payment,
    courtesy,
    isReturn,
    customer,
    courtesyTo,
    total,
    notes,
    costPerUnit:unitCost,
    lineCost,
    lineProfit
  };

  const saleId = await put('sales', saleRecord);
  saleRecord.id = saleId;

  // Crear/actualizar asiento contable automático en Finanzas
  try {
    await createJournalEntryForSalePOS(saleRecord);
  } catch (err) {
    console.error('No se pudo generar el asiento automático de esta venta', err);
  }

  // limpiar campos para el siguiente registro (incluye NOTAS)
  $('#sale-qty').value=1; 
  $('#sale-discount').value=0; 
  if (payment==='credito') $('#sale-customer').value=''; 
  $('#sale-courtesy-to').value='';
  $('#sale-notes').value=''; // limpiar notas
  const nextTotal = (courtesy?0:price).toFixed(2);
  const saleTotal2 = $('#sale-total');
  if (saleTotal2) {
    saleTotal2.value = nextTotal;
  }
  const sticky2 = $('#sticky-total');
  if (sticky2) {
    sticky2.textContent = nextTotal;
  }

  await renderDay(); await renderSummary(); await refreshSaleStockLabel(); await renderInventario();
  toast('Venta agregada');
}

async function renderCajaChica(){
  const main = document.getElementById('pc-main');
  const note = document.getElementById('pc-no-event-note');
  const lbl = document.getElementById('pc-event-info');
  if (!main || !note || !lbl) return;

  const evId = await getMeta('currentEventId');
  const evs = await getAll('events');
  const ev = evId ? evs.find(e => e.id === evId) : null;

  if (!evId || !ev){
    lbl.textContent = 'Evento activo: —';
    note.style.display = 'block';
    main.classList.add('disabled');
    updatePettySummaryUI(null);
    resetPettyInitialInputs();
    resetPettyFinalInputs();
    renderPettyMovements(null);
    return;
  }

  lbl.textContent = 'Evento activo: ' + ev.name;
  note.style.display = 'none';
  main.classList.remove('disabled');

  const pc = await getPettyCash(evId);
  updatePettySummaryUI(pc);
  fillPettyInitialFromPc(pc);
  fillPettyFinalFromPc(pc);
  renderPettyMovements(pc);
}

function updatePettySummaryUI(pc){
  const sum = computePettyCashSummary(pc || null);

  const setVal = (id, value, allowDash) => {
    const el = document.getElementById(id);
    if (!el) return;
    if (allowDash && (value === null || typeof value === 'undefined')){
      el.textContent = '—';
    } else {
      el.textContent = fmt(Number(value || 0));
    }
  };

  setVal('pc-nio-inicial', sum.nio.initial);
  setVal('pc-nio-entradas', sum.nio.entradas);
  setVal('pc-nio-salidas', sum.nio.salidas);
  setVal('pc-nio-teorico', sum.nio.teorico);
  setVal('pc-nio-final', sum.nio.final, true);
  setVal('pc-nio-diferencia', sum.nio.diferencia, true);

  setVal('pc-usd-inicial', sum.usd.initial);
  setVal('pc-usd-entradas', sum.usd.entradas);
  setVal('pc-usd-salidas', sum.usd.salidas);
  setVal('pc-usd-teorico', sum.usd.teorico);
  setVal('pc-usd-final', sum.usd.final, true);
  setVal('pc-usd-diferencia', sum.usd.diferencia, true);
}

function resetPettyInitialInputs(){
  if (typeof NIO_DENOMS === 'undefined' || typeof USD_DENOMS === 'undefined') return;

  NIO_DENOMS.forEach(d=>{
    const q = document.getElementById('pc-nio-q-'+d);
    const s = document.getElementById('pc-nio-sub-'+d);
    if (q) q.value = '0';
    if (s) s.textContent = '0.00';
  });

  USD_DENOMS.forEach(d=>{
    const q = document.getElementById('pc-usd-q-'+d);
    const s = document.getElementById('pc-usd-sub-'+d);
    if (q) q.value = '0';
    if (s) s.textContent = '0.00';
  });

  const tn = document.getElementById('pc-nio-total');
  const tu = document.getElementById('pc-usd-total');
  if (tn) tn.textContent = '0.00';
  if (tu) tu.textContent = '0.00';
}

function resetPettyFinalInputs(){
  if (typeof NIO_DENOMS === 'undefined' || typeof USD_DENOMS === 'undefined') return;

  NIO_DENOMS.forEach(d=>{
    const q = document.getElementById('pc-fnio-q-'+d);
    const s = document.getElementById('pc-fnio-sub-'+d);
    if (q) q.value = '0';
    if (s) s.textContent = '0.00';
  });

  USD_DENOMS.forEach(d=>{
    const q = document.getElementById('pc-fusd-q-'+d);
    const s = document.getElementById('pc-fusd-sub-'+d);
    if (q) q.value = '0';
    if (s) s.textContent = '0.00';
  });

  const tn = document.getElementById('pc-fnio-total');
  const tu = document.getElementById('pc-fusd-total');
  if (tn) tn.textContent = '0.00';
  if (tu) tu.textContent = '0.00';
}

function fillPettyInitialFromPc(pc){
  resetPettyInitialInputs();
  if (!pc || !pc.initial) return;
  const init = normalizePettySection(pc.initial);

  NIO_DENOMS.forEach(d=>{
    const key = String(d);
    const q = document.getElementById('pc-nio-q-'+d);
    const s = document.getElementById('pc-nio-sub-'+d);
    const qty = init.nio[key] || 0;
    if (q) q.value = String(qty);
    const sub = d * qty;
    if (s) s.textContent = fmt(sub);
  });

  USD_DENOMS.forEach(d=>{
    const key = String(d);
    const q = document.getElementById('pc-usd-q-'+d);
    const s = document.getElementById('pc-usd-sub-'+d);
    const qty = init.usd[key] || 0;
    if (q) q.value = String(qty);
    const sub = d * qty;
    if (s) s.textContent = fmt(sub);
  });

  const tn = document.getElementById('pc-nio-total');
  const tu = document.getElementById('pc-usd-total');
  if (tn) tn.textContent = fmt(init.totalNio || 0);
  if (tu) tu.textContent = fmt(init.totalUsd || 0);
}

function fillPettyFinalFromPc(pc){
  resetPettyFinalInputs();
  if (!pc || !pc.finalCount) return;
  const fin = normalizePettySection(pc.finalCount);

  NIO_DENOMS.forEach(d=>{
    const key = String(d);
    const q = document.getElementById('pc-fnio-q-'+d);
    const s = document.getElementById('pc-fnio-sub-'+d);
    const qty = fin.nio[key] || 0;
    if (q) q.value = String(qty);
    const sub = d * qty;
    if (s) s.textContent = fmt(sub);
  });

  USD_DENOMS.forEach(d=>{
    const key = String(d);
    const q = document.getElementById('pc-fusd-q-'+d);
    const s = document.getElementById('pc-fusd-sub-'+d);
    const qty = fin.usd[key] || 0;
    if (q) q.value = String(qty);
    const sub = d * qty;
    if (s) s.textContent = fmt(sub);
  });

  const tn = document.getElementById('pc-fnio-total');
  const tu = document.getElementById('pc-fusd-total');
  if (tn) tn.textContent = fmt(fin.totalNio || 0);
  if (tu) tu.textContent = fmt(fin.totalUsd || 0);
}

function recalcPettyInitialTotalsFromInputs(){
  if (typeof NIO_DENOMS === 'undefined' || typeof USD_DENOMS === 'undefined') return;
  let totalNio = 0;
  let totalUsd = 0;

  NIO_DENOMS.forEach(d=>{
    const q = document.getElementById('pc-nio-q-'+d);
    const s = document.getElementById('pc-nio-sub-'+d);
    const raw = q ? Number(q.value || 0) : 0;
    const qty = (Number.isFinite(raw) && raw > 0) ? raw : 0;
    const sub = d * qty;
    if (s) s.textContent = fmt(sub);
    totalNio += sub;
  });

  USD_DENOMS.forEach(d=>{
    const q = document.getElementById('pc-usd-q-'+d);
    const s = document.getElementById('pc-usd-sub-'+d);
    const raw = q ? Number(q.value || 0) : 0;
    const qty = (Number.isFinite(raw) && raw > 0) ? raw : 0;
    const sub = d * qty;
    if (s) s.textContent = fmt(sub);
    totalUsd += sub;
  });

  const tn = document.getElementById('pc-nio-total');
  const tu = document.getElementById('pc-usd-total');
  if (tn) tn.textContent = fmt(totalNio);
  if (tu) tu.textContent = fmt(totalUsd);
}

function recalcPettyFinalTotalsFromInputs(){
  if (typeof NIO_DENOMS === 'undefined' || typeof USD_DENOMS === 'undefined') return;
  let totalNio = 0;
  let totalUsd = 0;

  NIO_DENOMS.forEach(d=>{
    const q = document.getElementById('pc-fnio-q-'+d);
    const s = document.getElementById('pc-fnio-sub-'+d);
    const raw = q ? Number(q.value || 0) : 0;
    const qty = (Number.isFinite(raw) && raw > 0) ? raw : 0;
    const sub = d * qty;
    if (s) s.textContent = fmt(sub);
    totalNio += sub;
  });

  USD_DENOMS.forEach(d=>{
    const q = document.getElementById('pc-fusd-q-'+d);
    const s = document.getElementById('pc-fusd-sub-'+d);
    const raw = q ? Number(q.value || 0) : 0;
    const qty = (Number.isFinite(raw) && raw > 0) ? raw : 0;
    const sub = d * qty;
    if (s) s.textContent = fmt(sub);
    totalUsd += sub;
  });

  const tn = document.getElementById('pc-fnio-total');
  const tu = document.getElementById('pc-fusd-total');
  if (tn) tn.textContent = fmt(totalNio);
  if (tu) tu.textContent = fmt(totalUsd);
}

async function onSavePettyInitial(){
  const evId = await getMeta('currentEventId');
  if (!evId){
    alert('Debes activar un evento en la pestaña Vender antes de guardar Caja Chica.');
    return;
  }
  const pc = await getPettyCash(evId);

  const nio = {};
  const usd = {};

  NIO_DENOMS.forEach(d=>{
    const q = document.getElementById('pc-nio-q-'+d);
    const raw = q ? Number(q.value || 0) : 0;
    const qty = (Number.isFinite(raw) && raw > 0) ? raw : 0;
    nio[String(d)] = qty;
  });

  USD_DENOMS.forEach(d=>{
    const q = document.getElementById('pc-usd-q-'+d);
    const raw = q ? Number(q.value || 0) : 0;
    const qty = (Number.isFinite(raw) && raw > 0) ? raw : 0;
    usd[String(d)] = qty;
  });

  pc.initial = normalizePettySection({
    nio,
    usd,
    savedAt: new Date().toISOString()
  });

  await savePettyCash(pc);
  updatePettySummaryUI(pc);
  fillPettyInitialFromPc(pc);
  toast('Saldo inicial de Caja Chica guardado');
}

async function onSavePettyFinal(){
  const evId = await getMeta('currentEventId');
  if (!evId){
    alert('Debes activar un evento en la pestaña Vender antes de guardar el arqueo final.');
    return;
  }
  const pc = await getPettyCash(evId);

  const nio = {};
  const usd = {};

  NIO_DENOMS.forEach(d=>{
    const q = document.getElementById('pc-fnio-q-'+d);
    const raw = q ? Number(q.value || 0) : 0;
    const qty = (Number.isFinite(raw) && raw > 0) ? raw : 0;
    nio[String(d)] = qty;
  });

  USD_DENOMS.forEach(d=>{
    const q = document.getElementById('pc-fusd-q-'+d);
    const raw = q ? Number(q.value || 0) : 0;
    const qty = (Number.isFinite(raw) && raw > 0) ? raw : 0;
    usd[String(d)] = qty;
  });

  pc.finalCount = normalizePettySection({
    nio,
    usd,
    savedAt: new Date().toISOString()
  });

  await savePettyCash(pc);
  updatePettySummaryUI(pc);
  fillPettyFinalFromPc(pc);
  toast('Arqueo final de Caja Chica guardado');
}

function renderPettyMovements(pc){
  const tbody = document.getElementById('pc-mov-tbody');
  if (!tbody) return;
  tbody.innerHTML = '';

  if (!pc || !Array.isArray(pc.movements) || pc.movements.length === 0){
    return;
  }

  for (const m of pc.movements){
    const tr = document.createElement('tr');
    const tipoText = m.type === 'entrada' ? 'Entrada' : 'Salida';
    const currencyText = m.currency === 'USD' ? 'US$' : 'C$';
    const desc = m.description || '';
    tr.innerHTML = `
      <td>${m.date || ''}</td>
      <td>${tipoText}</td>
      <td>${currencyText}</td>
      <td>${fmt(Number(m.amount||0))}</td>
      <td>${desc.replace ? desc.replace(/</g,'&lt;').replace(/>/g,'&gt;') : desc}</td>
      <td><button class="btn-small btn-danger" data-movid="${m.id}">Eliminar</button></td>
    `;
    tbody.appendChild(tr);
  }
}

async function onAddPettyMovement(){
  const evId = await getMeta('currentEventId');
  if (!evId){
    alert('Debes activar un evento en la pestaña Vender antes de registrar movimientos de Caja Chica.');
    return;
  }

  const dateInput = document.getElementById('pc-mov-date');
  const typeSel = document.getElementById('pc-mov-type');
  const curSel  = document.getElementById('pc-mov-currency');
  const amtInput = document.getElementById('pc-mov-amount');
  const descInput = document.getElementById('pc-mov-desc');

  const now = new Date();
  const y = now.getFullYear();
  const m = String(now.getMonth()+1).padStart(2,'0');
  const d = String(now.getDate()).padStart(2,'0');
  const todayStr = `${y}-${m}-${d}`;

  const date = (dateInput && dateInput.value) ? dateInput.value : todayStr;
  const type = typeSel ? typeSel.value : 'entrada';
  const currency = curSel ? curSel.value : 'NIO';
  const rawAmt = amtInput ? Number(amtInput.value || 0) : 0;
  const amount = Number.isFinite(rawAmt) ? rawAmt : 0;
  const description = descInput ? (descInput.value || '').trim() : '';

  if (!amount || amount <= 0){
    alert('Ingresa un monto mayor a cero.');
    return;
  }
  if (type !== 'entrada' && type !== 'salida'){
    alert('Tipo de movimiento inválido.');
    return;
  }
  if (currency !== 'NIO' && currency !== 'USD'){
    alert('Moneda inválida.');
    return;
  }

  const pc = await getPettyCash(evId);
  if (!Array.isArray(pc.movements)) pc.movements = [];

  const newId = pc.movements.length ? Math.max(...pc.movements.map(m=>m.id||0)) + 1 : 1;

  pc.movements.push({
    id: newId,
    date,
    type,
    currency,
    amount,
    description
  });

  await savePettyCash(pc);
  updatePettySummaryUI(pc);
  renderPettyMovements(pc);

  if (amtInput) amtInput.value = '0.00';
  if (descInput) descInput.value = '';
}

async function onDeletePettyMovement(id){
  const evId = await getMeta('currentEventId');
  if (!evId) return;
  const pc = await getPettyCash(evId);
  if (!Array.isArray(pc.movements)) pc.movements = [];
  pc.movements = pc.movements.filter(m => m.id !== id);
  await savePettyCash(pc);
  updatePettySummaryUI(pc);
  renderPettyMovements(pc);
}

function bindCajaChicaEvents(){
  const inputsInit = document.querySelectorAll('#pc-table-nio input[type="number"], #pc-table-usd input[type="number"]');
  inputsInit.forEach(inp=>{
    inp.addEventListener('input', recalcPettyInitialTotalsFromInputs);
  });

  const inputsFinal = document.querySelectorAll('#pc-table-fnio input[type="number"], #pc-table-fusd input[type="number"]');
  inputsFinal.forEach(inp=>{
    inp.addEventListener('input', recalcPettyFinalTotalsFromInputs);
  });

  const btnSaveInit = document.getElementById('pc-btn-save-initial');
  if (btnSaveInit){
    btnSaveInit.addEventListener('click', (e)=>{
      e.preventDefault();
      onSavePettyInitial();
    });
  }

  const btnClearInit = document.getElementById('pc-btn-clear-initial');
  if (btnClearInit){
    btnClearInit.addEventListener('click', (e)=>{
      e.preventDefault();
      resetPettyInitialInputs();
    });
  }

  const btnSaveFinal = document.getElementById('pc-btn-save-final');
  if (btnSaveFinal){
    btnSaveFinal.addEventListener('click', (e)=>{
      e.preventDefault();
      onSavePettyFinal();
    });
  }

  const btnClearFinal = document.getElementById('pc-btn-clear-final');
  if (btnClearFinal){
    btnClearFinal.addEventListener('click', (e)=>{
      e.preventDefault();
      resetPettyFinalInputs();
    });
  }

  const btnAddMov = document.getElementById('pc-mov-add');
  if (btnAddMov){
    btnAddMov.addEventListener('click', (e)=>{
      e.preventDefault();
      onAddPettyMovement();
    });
  }

  const tbody = document.getElementById('pc-mov-tbody');
  if (tbody){
    tbody.addEventListener('click', (e)=>{
      const btn = e.target.closest('button[data-movid]');
      if (!btn) return;
      const id = Number(btn.dataset.movid);
      if (!id) return;
      onDeletePettyMovement(id);
    });
  }
}




async function findMissingCajaChicaCierres(selectedEvents, salesGrupo){
  const salesCount = new Map();
  for (const s of (salesGrupo || [])){
    if (!s || s.eventId == null) continue;
    salesCount.set(s.eventId, (salesCount.get(s.eventId) || 0) + 1);
  }

  const missing = [];
  for (const ev of (selectedEvents || [])){
    if (!ev) continue;

    const pc = await getPettyCash(ev.id);
    const hasSales = (salesCount.get(ev.id) || 0) > 0;
    const hasMov = !!(pc && Array.isArray(pc.movements) && pc.movements.length > 0);
    const isClosed = !!ev.closedAt;
    const hasFinal = !!(pc && pc.finalCount && pc.finalCount.savedAt);

    // Aviso solo si hubo actividad (ventas o movimientos) o si el evento ya fue cerrado,
    // y aún no existe arqueo final guardado.
    if ((hasSales || hasMov || isClosed) && !hasFinal){
      missing.push({
        id: ev.id,
        name: ev.name || '',
        closedAt: ev.closedAt || '',
        hasSales,
        hasMov
      });
    }
  }
  return missing;
}

async function getCierreTotalGrupoData(){
  const groupSelect = $('#filtro-grupo');
  if (!groupSelect){
    alert('No se encontró el filtro de grupo en la pestaña de eventos.');
    return null;
  }
  const groupVal = groupSelect.value || '';
  if (!groupVal){
    alert('Selecciona un grupo en la lista "Grupos" para generar el cierre total.');
    return null;
  }

  const events = await getAll('events');
  let selectedEvents;
  let groupLabel;
  if (groupVal === '__sin_grupo__'){
    selectedEvents = events.filter(ev => !(ev.groupName || '').trim());
    groupLabel = '[Sin grupo]';
  } else {
    selectedEvents = events.filter(ev => (ev.groupName || '').trim() === groupVal);
    groupLabel = groupVal;
  }
  if (!selectedEvents.length){
    alert('No hay eventos para ese grupo.');
    return null;
  }

  const sales = await getAll('sales');
  const eventIds = new Set(selectedEvents.map(ev=>ev.id));
  const salesGrupo = sales.filter(s => eventIds.has(s.eventId));

  const data = {
    groupValue: groupVal,
    groupLabel,
    eventos: [],
    totalGrupo: 0,
    porPago: {},
    cortesiasUnid: 0,
    devolUnid: 0,
    devolMonto: 0,
    presentaciones: [],
    pettyWarnings: { missingFinalEvents: [] }
  };

  if (!salesGrupo.length){
    data.eventos = selectedEvents.map(ev => ({
      id: ev.id,
      name: ev.name || '',
      createdAt: ev.createdAt || '',
      closedAt: ev.closedAt || '',
      total: 0
    }));
    data.pettyWarnings.missingFinalEvents = await findMissingCajaChicaCierres(selectedEvents, salesGrupo);
    return data;
  }

  const totalsPorEvento = new Map();
  for (const ev of selectedEvents){
    totalsPorEvento.set(ev.id, 0);
  }

  const presentacionesMap = new Map();

  for (const s of salesGrupo){
    const t = s.total || 0;
    const qty = s.qty || 0;
    const pago = s.payment || 'otro';

    data.totalGrupo += t;
    if (!data.porPago[pago]) data.porPago[pago] = 0;
    data.porPago[pago] += t;

    if (s.courtesy){
      data.cortesiasUnid += Math.abs(qty);
    }
    if (s.isReturn){
      data.devolUnid += Math.abs(qty);
      data.devolMonto += Math.abs(t);
    }

    if (totalsPorEvento.has(s.eventId)){
      totalsPorEvento.set(s.eventId, totalsPorEvento.get(s.eventId) + t);
    }

    if (!s.courtesy && !s.isReturn){
      const nombre = s.productName || 'N/D';
      let acc = presentacionesMap.get(nombre);
      if (!acc) acc = { unidades: 0, monto: 0 };
      acc.unidades += qty;
      acc.monto += t;
      presentacionesMap.set(nombre, acc);
    }
  }

  data.eventos = selectedEvents.map(ev => ({
    id: ev.id,
    name: ev.name || '',
    createdAt: ev.createdAt || '',
    closedAt: ev.closedAt || '',
    total: totalsPorEvento.get(ev.id) || 0
  }));

  data.presentaciones = Array.from(presentacionesMap.entries()).map(([name, info]) => ({
    name,
    unidades: info.unidades,
    monto: info.monto
  }));

  data.pettyWarnings.missingFinalEvents = await findMissingCajaChicaCierres(selectedEvents, salesGrupo);

  return data;
}

async function computeCierreTotalGrupo(){
  const data = await getCierreTotalGrupoData();
  if (!data) return;

  const resumenEl = document.getElementById('cierre-total-resumen');
  const presEl = document.getElementById('cierre-total-presentaciones');
  if (!resumenEl || !presEl) return;

  if (!data.eventos.length && !data.totalGrupo && !Object.keys(data.porPago).length){
    resumenEl.innerHTML = '<p class="muted">No hay ventas registradas para este grupo.</p>';
    presEl.innerHTML = '';
    return;
  }

  let html = '';
  html += `<div><strong>Grupo:</strong> ${data.groupLabel}</div>`;
  html += `<div><strong>Eventos incluidos:</strong> ${data.eventos.length}</div>`;
  const missingCaja = (data.pettyWarnings && Array.isArray(data.pettyWarnings.missingFinalEvents)) ? data.pettyWarnings.missingFinalEvents : [];
  if (missingCaja.length){
    const items = missingCaja.map(e=>{
      const flags = [];
      if (e.hasSales) flags.push('ventas');
      if (e.hasMov) flags.push('movimientos');
      if (e.closedAt) flags.push('cerrado');
      const why = flags.length ? ` (${flags.join(', ')})` : '';
      return `<li>${(e.name || ('Evento #' + e.id))}${why}</li>`;
    }).join('');
    html += `<div class="warn"><strong>⚠️ Aviso:</strong> faltan cierres diarios (arqueo final) de Caja Chica en ${missingCaja.length} evento(s) del grupo. Puedes continuar, pero el cierre total quedará sin esa confirmación.<ul>${items}</ul></div>`;
  }

  html += `<div><strong>Ventas totales del grupo:</strong> C$ ${fmt(data.totalGrupo)}</div>`;
  html += '<hr>';
  html += '<div><strong>Por forma de pago:</strong></div>';
  html += '<ul>';

  const ordenPagos = ['efectivo','transferencia','tarjeta','credito'];
  const ya = new Set();
  for (const metodo of ordenPagos){
    if (data.porPago[metodo] != null){
      html += `<li>${metodo}: C$ ${fmt(data.porPago[metodo])}</li>`;
      ya.add(metodo);
    }
  }
  for (const metodo in data.porPago){
    if (!ya.has(metodo)){
      html += `<li>${metodo}: C$ ${fmt(data.porPago[metodo])}</li>`;
    }
  }
  html += '</ul>';
  html += `<div><strong>Cortesías (unidades):</strong> ${data.cortesiasUnid}</div>`;
  html += `<div><strong>Devoluciones:</strong> ${data.devolUnid} u. | C$ ${fmt(data.devolMonto)}</div>`;

  resumenEl.innerHTML = html;

  if (!data.presentaciones.length){
    presEl.innerHTML = '<p class="muted">No hay ventas normales (sin cortesías ni devoluciones) en este grupo.</p>';
  } else {
    const rows = data.presentaciones.slice().sort((a,b)=>a.name.localeCompare(b.name,'es-NI'));
    let tabla = '<table class="table small"><thead><tr><th>Presentación</th><th>Unidades vendidas</th><th>Ventas C$</th></tr></thead><tbody>';
    for (const p of rows){
      tabla += `<tr><td>${p.name}</td><td>${p.unidades}</td><td>C$ ${fmt(p.monto)}</td></tr>`;
    }
    tabla += '</tbody></table>';
    presEl.innerHTML = tabla;
  }
}

async function exportCierreTotalGrupoExcel(){
  const data = await getCierreTotalGrupoData();
  if (!data) return;

  const missingCaja = (data.pettyWarnings && Array.isArray(data.pettyWarnings.missingFinalEvents)) ? data.pettyWarnings.missingFinalEvents : [];
  if (missingCaja.length){
    const lines = missingCaja.map(e => `- ${(e.name || ('Evento #'+e.id))}`).join('
');
    const ok = confirm(`Aviso: faltan cierres diarios (arqueo final) de Caja Chica en ${missingCaja.length} evento(s) del grupo:

${lines}

¿Deseas exportar el Cierre Total de todas formas?`);
    if (!ok) return;
  }


  if (typeof XLSX === 'undefined'){
    alert('No se pudo generar el archivo de Excel (librería XLSX no cargada). Revisa tu conexión a internet.');
    return;
  }

  const sheets = [];

  // Hoja Resumen
  const resumenRows = [];
  resumenRows.push(['Grupo', data.groupLabel]);
  resumenRows.push(['Eventos incluidos', data.eventos.length]);
  resumenRows.push(['Ventas totales del grupo (C$)', data.totalGrupo]);
  resumenRows.push([]);
  resumenRows.push(['Forma de pago', 'Monto C$']);

  const ordenPagos = ['efectivo','transferencia','tarjeta','credito'];
  const ya = new Set();
  for (const metodo of ordenPagos){
    if (data.porPago[metodo] != null){
      resumenRows.push([metodo, data.porPago[metodo]]);
      ya.add(metodo);
    }
  }
  for (const metodo in data.porPago){
    if (!ya.has(metodo)){
      resumenRows.push([metodo, data.porPago[metodo]]);
    }
  }
  resumenRows.push([]);
  resumenRows.push(['Cortesías (unidades)', data.cortesiasUnid]);
  resumenRows.push(['Devoluciones unidades', data.devolUnid]);
  resumenRows.push(['Devoluciones monto C$', data.devolMonto]);
  sheets.push({ name: 'Resumen', rows: resumenRows });

  // Hoja Eventos
  const eventosRows = [];
  eventosRows.push(['id','evento','creado','cerrado','total C$']);
  for (const ev of data.eventos){
    eventosRows.push([
      ev.id,
      ev.name,
      ev.createdAt,
      ev.closedAt,
      ev.total
    ]);
  }
  sheets.push({ name: 'Eventos', rows: eventosRows });

  // Hoja Presentaciones
  const presRows = [];
  presRows.push(['presentacion','unidades vendidas','ventas C$']);
  if (data.presentaciones.length){
    for (const p of data.presentaciones){
      presRows.push([p.name, p.unidades, p.monto]);
    }
  }
  sheets.push({ name: 'Presentaciones', rows: presRows });

  const wb = XLSX.utils.book_new();
  for (const sh of sheets){
    const ws = XLSX.utils.aoa_to_sheet(sh.rows);
    XLSX.utils.book_append_sheet(wb, ws, sh.name);
  }

  const safeGroup = data.groupLabel.replace(/[\\/:*?\[\]]/g,' ');
  const filename = `cierre_total_${safeGroup || 'grupo'}.xlsx`;
  XLSX.writeFile(wb, filename);
}



async function getCierreCajaChicaGrupoData(){
  const groupSelect = $('#filtro-grupo');
  if (!groupSelect){
    alert('No se encontró el filtro de grupo en la pestaña de eventos.');
    return null;
  }
  const groupVal = groupSelect.value || '';
  if (!groupVal){
    alert('Selecciona un grupo en la lista "Grupos" para generar el cierre de Caja Chica.');
    return null;
  }

  const events = await getAll('events');
  let selectedEvents;
  let groupLabel;
  if (groupVal === '__sin_grupo__'){
    selectedEvents = events.filter(ev => !(ev.groupName || '').trim());
    groupLabel = '[Sin grupo]';
  } else {
    selectedEvents = events.filter(ev => (ev.groupName || '').trim() === groupVal);
    groupLabel = groupVal;
  }
  if (!selectedEvents.length){
    alert('No hay eventos para ese grupo.');
    return null;
  }

  // Obtener Caja Chica por evento
  const pettyList = [];
  for (const ev of selectedEvents){
    const pc = await getPettyCash(ev.id);
    pettyList.push(pc);
  }

  const eventos = [];
  const totalNio = { initial:0, entradas:0, salidas:0, teorico:0, final:0, diferencia:0, tieneFinal:false, tieneDif:false };
  const totalUsd = { initial:0, entradas:0, salidas:0, teorico:0, final:0, diferencia:0, tieneFinal:false, tieneDif:false };

  for (let i = 0; i < selectedEvents.length; i++){
    const ev = selectedEvents[i];
    const pc = pettyList[i];
    const summary = computePettyCashSummary(pc);

    const nio = summary.nio || {};
    const usd = summary.usd || {};

    eventos.push({
      id: ev.id,
      name: ev.name || '',
      createdAt: ev.createdAt || '',
      closedAt: ev.closedAt || '',
      nio,
      usd
    });

    // Acumulados NIO
    totalNio.initial += nio.initial || 0;
    totalNio.entradas += nio.entradas || 0;
    totalNio.salidas += nio.salidas || 0;
    totalNio.teorico += nio.teorico || 0;
    if (nio.final != null){
      totalNio.final += nio.final;
      totalNio.tieneFinal = true;
    }
    if (nio.diferencia != null){
      totalNio.diferencia += nio.diferencia;
      totalNio.tieneDif = true;
    }

    // Acumulados USD
    totalUsd.initial += usd.initial || 0;
    totalUsd.entradas += usd.entradas || 0;
    totalUsd.salidas += usd.salidas || 0;
    totalUsd.teorico += usd.teorico || 0;
    if (usd.final != null){
      totalUsd.final += usd.final;
      totalUsd.tieneFinal = true;
    }
    if (usd.diferencia != null){
      totalUsd.diferencia += usd.diferencia;
      totalUsd.tieneDif = true;
    }
  }

  if (!totalNio.tieneFinal) totalNio.final = null;
  if (!totalNio.tieneDif) totalNio.diferencia = null;
  if (!totalUsd.tieneFinal) totalUsd.final = null;
  if (!totalUsd.tieneDif) totalUsd.diferencia = null;

  return {
    groupLabel,
    eventos,
    nio: totalNio,
    usd: totalUsd
  };
}

async function computeCierreCajaChicaGrupo(){
  const data = await getCierreCajaChicaGrupoData();
  if (!data) return;

  const resumenEl = document.getElementById('cierre-caja-resumen');
  const eventosEl = document.getElementById('cierre-caja-eventos');
  if (!resumenEl || !eventosEl) return;

  if (!data.eventos.length){
    resumenEl.innerHTML = '<p class="muted">No hay datos de Caja Chica para este grupo.</p>';
    eventosEl.innerHTML = '';
    return;
  }

  let html = '';
  html += `<div><strong>Grupo:</strong> ${data.groupLabel}</div>`;
  html += `<div><strong>Eventos incluidos:</strong> ${data.eventos.length}</div>`;
  html += '<hr>';
  html += '<h4>Córdobas (C$)</h4>';
  html += '<ul>';
  html += `<li>Saldo inicial: C$ ${fmt(data.nio.initial)}</li>`;
  html += `<li>Entradas: C$ ${fmt(data.nio.entradas)}</li>`;
  html += `<li>Salidas: C$ ${fmt(data.nio.salidas)}</li>`;
  html += `<li>Saldo teórico: C$ ${fmt(data.nio.teorico)}</li>`;
  if (data.nio.final != null){
    html += `<li>Saldo final contado: C$ ${fmt(data.nio.final)}</li>`;
  }
  if (data.nio.diferencia != null){
    html += `<li>Diferencia: C$ ${fmt(data.nio.diferencia)}</li>`;
  }
  html += '</ul>';

  html += '<h4>Dólares (US$)</h4>';
  html += '<ul>';
  html += `<li>Saldo inicial: US$ ${fmt(data.usd.initial)}</li>`;
  html += `<li>Entradas: US$ ${fmt(data.usd.entradas)}</li>`;
  html += `<li>Salidas: US$ ${fmt(data.usd.salidas)}</li>`;
  html += `<li>Saldo teórico: US$ ${fmt(data.usd.teorico)}</li>`;
  if (data.usd.final != null){
    html += `<li>Saldo final contado: US$ ${fmt(data.usd.final)}</li>`;
  }
  if (data.usd.diferencia != null){
    html += `<li>Diferencia: US$ ${fmt(data.usd.diferencia)}</li>`;
  }
  html += '</ul>';

  resumenEl.innerHTML = html;

  // Tabla por evento
  const rows = data.eventos.slice();
  if (!rows.length){
    eventosEl.innerHTML = '<p class="muted">No hay eventos con Caja Chica registrada en este grupo.</p>';
    return;
  }

  let tabla = '<table class="table small"><thead><tr>';
  tabla += '<th>Evento</th><th>NIO inicial</th><th>NIO entradas</th><th>NIO salidas</th><th>NIO teórico</th><th>NIO final</th><th>NIO diferencia</th>';
  tabla += '<th>USD inicial</th><th>USD entradas</th><th>USD salidas</th><th>USD teórico</th><th>USD final</th><th>USD diferencia</th>';
  tabla += '</tr></thead><tbody>';
  for (const e of rows){
    const n = e.nio || {}; const u = e.usd || {};
    tabla += '<tr>';
    tabla += `<td>${e.name}</td>`;
    tabla += `<td>C$ ${fmt(n.initial || 0)}</td>`;
    tabla += `<td>C$ ${fmt(n.entradas || 0)}</td>`;
    tabla += `<td>C$ ${fmt(n.salidas || 0)}</td>`;
    tabla += `<td>C$ ${fmt(n.teorico || 0)}</td>`;
    tabla += `<td>${n.final != null ? 'C$ '+fmt(n.final) : '—'}</td>`;
    tabla += `<td>${n.diferencia != null ? 'C$ '+fmt(n.diferencia) : '—'}</td>`;
    tabla += `<td>US$ ${fmt(u.initial || 0)}</td>`;
    tabla += `<td>US$ ${fmt(u.entradas || 0)}</td>`;
    tabla += `<td>US$ ${fmt(u.salidas || 0)}</td>`;
    tabla += `<td>US$ ${fmt(u.teorico || 0)}</td>`;
    tabla += `<td>${u.final != null ? 'US$ '+fmt(u.final) : '—'}</td>`;
    tabla += `<td>${u.diferencia != null ? 'US$ '+fmt(u.diferencia) : '—'}</td>`;
    tabla += '</tr>';
  }
  tabla += '</tbody></table>';
  eventosEl.innerHTML = tabla;
}

async function exportCierreCajaChicaGrupoExcel(){
  const data = await getCierreCajaChicaGrupoData();
  if (!data) return;

  if (typeof XLSX === 'undefined'){
    alert('No se pudo generar el archivo de Excel (librería XLSX no cargada). Revisa tu conexión a internet.');
    return;
  }

  const sheets = [];

  // Hoja ResumenCajaChica
  const resumenRows = [];
  resumenRows.push(['Grupo', data.groupLabel]);
  resumenRows.push([]);
  resumenRows.push(['Moneda','Saldo inicial','Entradas','Salidas','Saldo teórico','Saldo final','Diferencia']);
  resumenRows.push(['Córdobas (C$)', data.nio.initial, data.nio.entradas, data.nio.salidas, data.nio.teorico, data.nio.final, data.nio.diferencia]);
  resumenRows.push(['Dólares (US$)', data.usd.initial, data.usd.entradas, data.usd.salidas, data.usd.teorico, data.usd.final, data.usd.diferencia]);
  sheets.push({ name: 'ResumenCajaChica', rows: resumenRows });

  // Hoja EventosCajaChica
  const eventosRows = [];
  eventosRows.push(['id','evento','creado','cerrado','NIO inicial','NIO entradas','NIO salidas','NIO teórico','NIO final','NIO diferencia','USD inicial','USD entradas','USD salidas','USD teórico','USD final','USD diferencia']);
  for (const e of data.eventos){
    const n = e.nio || {}; const u = e.usd || {};
    eventosRows.push([
      e.id,
      e.name,
      e.createdAt,
      e.closedAt,
      n.initial || 0,
      n.entradas || 0,
      n.salidas || 0,
      n.teorico || 0,
      n.final != null ? n.final : '',
      n.diferencia != null ? n.diferencia : '',
      u.initial || 0,
      u.entradas || 0,
      u.salidas || 0,
      u.teorico || 0,
      u.final != null ? u.final : '',
      u.diferencia != null ? u.diferencia : ''
    ]);
  }
  sheets.push({ name: 'EventosCajaChica', rows: eventosRows });

  const wb = XLSX.utils.book_new();
  for (const sh of sheets){
    const ws = XLSX.utils.aoa_to_sheet(sh.rows);
    XLSX.utils.book_append_sheet(wb, ws, sh.name);
  }

  const safeGroup = data.groupLabel.replace(/[\/:*?\[\]]/g,' ');
  const filename = `caja_chica_${safeGroup || 'grupo'}.xlsx`;
  XLSX.writeFile(wb, filename);
}



document.addEventListener('DOMContentLoaded', init);
