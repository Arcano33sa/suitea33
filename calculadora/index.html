<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Calculadora de Producci√≥n - Arcano 33</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#111111" />
  <link rel="icon" type="image/png" sizes="32x32" href="logo-icon-192.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="logo-icon-192.png" />
  <link rel="manifest" href="manifest.webmanifest?v=4.20.42" />
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 1rem;
      background: #111;
      color: #f5f5f5;
    }
    html, body { overflow-x: hidden; }

    /* iPad-first: mantener caducidad/hebreo/receta visibles y SIN scroll horizontal */
    .a33-ipad-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      align-items: start;
    }
    .a33-ipad-grid > .section { min-width: 0; margin-top: 0; }

    @media (min-width: 880px) {
      .a33-ipad-grid {
        grid-template-columns: 0.95fr 1.05fr;
      }
    }

    .a33-fechas-badges {
      margin-top: 0.4rem;
      margin-bottom: 0.25rem;
      gap: 0.45rem;
    }
    .a33-fechas-badges .badge {
      font-size: 0.76rem;
      border-color: rgba(221,191,100,0.32);
      background: rgba(0,0,0,0.22);
      white-space: normal;
    }

    .a33-fechas-legacy { display: block; }
    @media (min-width: 880px) {
      .a33-fechas-legacy { display: none; }
    }

    .a33-table-wrap {
      overflow-x: hidden;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      border-radius: 10px;
    }
    .a33-table-wrap--recetas { max-height: min(460px, 62vh); }

    /* Tablas sin overflow-x: compactas y wrap en iPad */
    @media (max-width: 1024px) {
      table { table-layout: fixed; }
      th, td { padding: 0.22rem; }
      th { white-space: normal; }
      td, th { min-width: 0; }
      input[type="number"], input[type="text"], input[type="date"] { min-width: 0; }
    }

    /* Bot√≥n principal en formato pastilla (sin tapar contenido) */
    .btn-main { border-radius: 999px; padding: 0.6rem 1rem; }
    .btn-secondary { border-radius: 999px; }

    h1, h2, h3 {
      margin-top: 0.5rem;
      margin-bottom: 0.5rem;
    }
    h1 {
      font-size: 1.5rem;
      text-align: center;
    }
    h2 {
      font-size: 1.1rem;
      margin-top: 1.5rem;
    }
    h3 {
      font-size: 0.95rem;
      margin-top: 0.75rem;
    }
    .app-container {
      max-width: 1000px;
      margin: 0 auto;
      background: #1b1b1b;
      border-radius: 10px;
      padding: 1rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.6);
      border: 1px solid #333;
    }
    .subtitle {
      text-align: center;
      font-size: 0.85rem;
      color: #bbb;
      margin-bottom: 1rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
      font-size: 0.85rem;
    }
    th, td {
      border: 1px solid #333;
      padding: 0.35rem;
      text-align: center;
    }
    th {
      background: #272727;
      /* Nota:
         Estas tablas viven dentro de contenedores con max-height + overflow.
         En iPad/iOS, un `top` grande en headers sticky puede tapar filas (ej. Pulso/Media).
         Aqu√≠ el sticky es relativo al scroll del contenedor, as√≠ que `top: 0` es lo correcto. */
      position: sticky;
      top: 0;
      z-index: 2;
    }
    input[type="number"],
    input[type="text"],
    input[type="date"],
    textarea {
      width: 100%;
      padding: 0.2rem;
      background: #111;
      border: 1px solid #444;
      border-radius: 4px;
      color: #f5f5f5;
      font-size: 0.8rem;
    }
    textarea {
      resize: vertical;
      min-height: 60px;
    }
    input[type="number"]:focus,
    input[type="text"]:focus,
    input[type="date"]:focus,
    textarea:focus {
      outline: none;
      border-color: #ddbf64;
      box-shadow: 0 0 0 1px #ddbf64;
    }
    .section {
      margin-top: 1rem;
    }
    .hint {
      font-size: 0.8rem;
      color: #aaa;
      margin-top: 0.25rem;
    }
    .btn-main {
      margin-top: 1rem;
      width: 100%;
      padding: 0.7rem;
      border: none;
      border-radius: 6px;
      background: linear-gradient(135deg, #7b1818, #ddbf64);
      color: #111;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
    }
    .btn-main:hover {
      filter: brightness(1.05);
    }
    .btn-secondary {
      margin-top: 0.5rem;
      padding: 0.4rem 0.8rem;
      border-radius: 6px;
      border: 1px solid #444;
      background: #222;
      color: #eee;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .btn-secondary:hover {
      background: #2c2c2c;
    }
    .inline-input-btn {
      display: flex;
      gap: 0.4rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .inline-input-btn input {
      flex: 1 1 auto;
      min-width: 0;
    }
    .btn-pill {
      padding: 0.28rem 0.6rem;
      border-radius: 999px;
      border: 1px solid #444;
      background: #222;
      color: #eee;
      font-weight: 600;
      font-size: 0.78rem;
      cursor: pointer;
      white-space: nowrap;
      flex: 0 0 auto;
    }
    .btn-pill:hover {
      background: #2c2c2c;
    }
    .btn-pill:active {
      transform: translateY(1px);
    }

    .results {
      margin-top: 1rem;
      padding: 0.7rem;
      border-radius: 8px;
      background: #161616;
      border: 1px solid #333;
    }
    .results-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .flex-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    .badge {
      padding: 0.3rem 0.6rem;
      border-radius: 999px;
      background: #222;
      border: 1px solid #444;
      font-size: 0.75rem;
      color: #eee;
    }
    .logo-container {
      display: flex;
      justify-content: center;
      margin-bottom: 0.5rem;
      margin-top: 0.5rem;
    }
    .logo-container img {
      width: 96px;
      height: auto;
      border-radius: 16px;
    }
    .fechas-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .fechas-row > div {
      flex: 1 1 140px;
    }
    @media (max-width: 768px) {
      table {
        font-size: 0.78rem;
      }
      th, td {
        padding: 0.25rem;
      }
    }
  
    /* Etapa 2: pill de estado de c√≥digo (compacto, sin scroll horizontal) */
    .a33-pill-code {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.18rem 0.55rem;
      border-radius: 999px;
      font-size: 0.72rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      line-height: 1;
      white-space: nowrap;
      border: 1px solid #444;
      user-select: none;
    }
    .a33-pill-sugerido {
      background: rgba(221, 191, 100, 0.12);
      color: #ddbf64;
      border-color: rgba(221, 191, 100, 0.35);
    }
    .a33-pill-editado {
      background: rgba(123, 24, 24, 0.18);
      color: #f5f5f5;
      border-color: rgba(221, 191, 100, 0.25);
    }
    .a33-pill-ok {
      background: rgba(221, 191, 100, 0.22);
      color: #111;
      border-color: rgba(221, 191, 100, 0.6);
    }

    /* A33 ‚Äî Modal compacto (iPad-friendly) */
    .a33-modal[hidden] { display: none !important; }
    .a33-modal {
      position: fixed;
      inset: 0;
      padding: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.66);
      z-index: 9999;
    }
    .a33-modal-card {
      width: 100%;
      max-width: 520px;
      background: #1b1b1b;
      border: 1px solid #333;
      border-radius: 14px;
      padding: 0.9rem;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      overflow: hidden;
    }
    .a33-modal-text {
      font-size: 0.92rem;
      line-height: 1.35;
      color: #eee;
      word-break: break-word;
    }
    .a33-mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.9em;
      padding: 0 0.15rem;
    }
    .a33-modal-actions {
      margin-top: 0.85rem;
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      flex-wrap: wrap;
    }
    .a33-btn-primary-pill {
      border: none;
      background: linear-gradient(135deg, #7b1818, #ddbf64);
      color: #111;
    }
    .a33-btn-primary-pill:hover { filter: brightness(1.05); }

  </style>
  <link rel="stylesheet" href="/assets/css/a33-header.css?v=4.20.42" />
</head>
<body>
  <header class="a33-header" role="banner">
    <a class="a33-btn-menu" href="../index.html" aria-label="Volver al Men√∫ principal">‚Üê Men√∫ principal</a>
    <div class="a33-title">Calculadora</div>
    <div class="a33-version">v4.20.42</div>
  </header>

  <div class="app-container">
    <div class="logo-container">
      <img src="logo-icon-192.png" alt="Arcano 33" />
    </div>
    <h1>Calculadora de Producci√≥n ‚Äì Arcano 33</h1>
    <p class="subtitle">
      Define la receta por presentaci√≥n y luego indica cu√°ntas vas a producir. La app te suma la materia prima üîÆ
    </p>

    <div class="a33-ipad-grid">
    <div class="section">
      <h2>0. Datos del lote</h2>
      <p class="hint">
        Escribe el nombre o c√≥digo del lote y la fecha de producci√≥n. La fecha de caducidad se calcula 2 meses despu√©s.
      </p>
      <div class="fechas-row">
        <div>
          <label for="lote">C√≥digo de lote</label>
          <div class="inline-input-btn">
            <input type="text" id="lote" placeholder="Ej: A330XX119TEV5786" autocomplete="off" />
            <span id="pill-codigo-estado" class="a33-pill-code a33-pill-sugerido">SUGERIDO</span>
            <button type="button" id="btn-regenerar-codigo" class="btn-pill">Regenerar</button>
          </div>
        </div>
        <div>
          <label for="fecha-produccion">Fecha de producci√≥n</label>
          <input type="date" id="fecha-produccion" />
        </div>
      </div>
      <div class="a33-fechas-badges flex-row" aria-label="Fechas del lote">
        <div class="badge" id="badge-caducidad">Caducidad: Calcula para ver‚Ä¶</div>
        <div class="badge" id="badge-hebreo">Hebreo: Calcula para ver‚Ä¶</div>
      </div>
      <p class="hint a33-fechas-legacy" id="texto-caducidad">Fecha de caducidad: ‚Äî</p>
      <p class="hint a33-fechas-legacy" id="texto-fecha-hebreo">Fecha hebrea (producci√≥n): ‚Äî</p>

      <h3>Notas del lote</h3>
      <textarea id="notas" placeholder="Ej: Pedido para evento, sabor cl√°sico, entrega s√°bado por la tarde..."></textarea>
    </div>

    <div class="section">
      <h2>1. Receta base (ml por unidad de cada presentaci√≥n)</h2>
      <p class="hint">
        Aqu√≠ pones cu√°ntos ml de <strong>vino, vodka, jugo, sirope y agua pura</strong> lleva 1 unidad de cada presentaci√≥n.
      </p>
      <div class="a33-table-wrap a33-table-wrap--recetas">
        <table id="recetas-table">
          <thead>
            <tr>
              <th>Presentaci√≥n</th>
              <th>Vino (ml)</th>
              <th>Vodka (ml)</th>
              <th>Jugo (ml)</th>
              <th>Sirope (ml)</th>
              <th>Agua pura (ml)</th>
              <th>Costo unitario (C$)</th>
            </tr>
          </thead>
          <tbody>
          </tbody>
        </table>
      </div>
      <button id="btn-guardar-receta" class="btn-secondary">Guardar receta en este navegador</button>
      <p class="hint">Se guarda en el navegador (localStorage). No necesitas cuenta ni internet.</p>
    </div>
    </div>

    <div class="section">
      <h2>2. Plan de producci√≥n (unidades a preparar)</h2>
      <p class="hint">
        Escribe cu√°ntas unidades har√°s de cada presentaci√≥n. Deja en blanco lo que no vayas a hacer.
      </p>
      <div class="a33-table-wrap a33-table-wrap--plan">
        <table id="plan-table">
          <thead>
            <tr>
              <th>Presentaci√≥n</th>
              <th>Unidades a producir</th>
            </tr>
          </thead>
          <tbody>
          </tbody>
        </table>
      </div>
    </div>

    <button id="btn-calcular" class="btn-main">Calcular totales de materia prima</button>
    <p id="hint-resultados" class="hint">Resultados: calcula para ver el resumen (materia prima, caducidad y costos).</p>

    <div id="resultados" class="results" style="display:none;">
      <div class="results-title">3. Totales de materia prima necesaria</div>
      <div id="resumen-lote"></div>
      <div id="resumen-fechas"></div>
      <div id="totales-ingredientes"></div>
      <div id="resumen-costos"></div>

      <div class="results-title" style="margin-top:0.8rem;">Resumen de volumen final</div>
      <div id="resumen-volumen"></div>

      <button id="btn-guardar-lote" class="btn-secondary">Guardar c√°lculo como lote</button>
      <p class="hint">Guardar√° este c√°lculo en el Control de Lotes interno.</p>
      <button id="btn-exportar" class="btn-secondary">Exportar informaci√≥n del lote (TXT)</button>
      <p class="hint">Se descargar√° un archivo .txt con el resumen del lote.</p>
    </div>

    <button id="btn-limpiar" class="btn-secondary">Limpiar cantidades (no borra recetas)</button>
  </div>

  <!-- Modal: c√≥digo duplicado (Etapa 3) -->
  <div id="a33-modal-dup-codigo" class="a33-modal" hidden aria-hidden="true">
    <div class="a33-modal-card" role="dialog" aria-modal="true" aria-labelledby="a33-modal-dup-text">
      <div id="a33-modal-dup-text" class="a33-modal-text"></div>
      <div class="a33-modal-actions">
        <button id="a33-modal-dup-aplicar" class="btn-pill a33-btn-primary-pill" type="button">Aplicar</button>
        <button id="a33-modal-dup-cancelar" class="btn-pill" type="button">Cancelar</button>
      </div>
    </div>
  </div>


  <script src="/assets/js/a33-storage.js?v=4.20.42"></script>
  <script src="/assets/js/a33-presentations.js?v=4.20.42"></script>
  <script src="/assets/js/a33-auth.js?v=4.20.42"></script>
  <script>
    if (!(A33Auth.isConfigured() && A33Auth.isAuthenticated())){
      location.href = "../index.html";
    }
  </script>
  <script>
    const INGREDIENTES = ["vino", "vodka", "jugo", "sirope", "agua"];
    const PRESENTACIONES = [
      { id: "pulso",  nombre: "Pulso 250 ml",  volumenMl: 250 },
      { id: "media",  nombre: "Media 375 ml",  volumenMl: 375 },
      { id: "djeba",  nombre: "Djeba 750 ml",  volumenMl: 750 },
      { id: "litro",  nombre: "Litro 1000 ml", volumenMl: 1000 },
      { id: "galon",  nombre: "Gal√≥n 3750 ml", volumenMl: 3750 }
    ];
    const STORAGE_RECETAS_KEY = "arcano33_recetas_v1";
    const STORAGE_LOTE_KEY = "arcano33_lote_actual";
    const STORAGE_FECHA_PROD_KEY = "arcano33_fecha_produccion";
    const STORAGE_NOTAS_KEY = "arcano33_notas_lote";
    const STORAGE_KEY_INVENTARIO = "arcano33_inventario";

    // Etapa 2: C√≥digo de lote AUTO (editable) con X=eco + fecha hebrea
    const STORAGE_LOTE_CODE_MODE_KEY = "arcano33_calc_codigo_mode"; // AUTO | MANUAL
    const STORAGE_LOTE_SEQ_LAST_KEY = "arcano33_calc_ultimo_consecutivo"; // 4 d√≠gitos (√∫ltimo usado)
    const STORAGE_LOTE_SEQ_CURRENT_KEY = "arcano33_calc_consecutivo_actual"; // 4 d√≠gitos (auto en curso)
    let A33CodigoLoteMode = "AUTO";
    let A33AutoSeq = "";
    let A33Hebreo = { hd:"", hm:"", hy:"", hm3:"", hy4:"" };
    let A33SuppressCodigoInput = false;
    let A33HasCalculoPrevio = false;
    let A33SuggestedCode = "";




    function setPillEstadoCodigo(state) {
      const el = document.getElementById("pill-codigo-estado");
      if (!el) return;
      const s = String(state || "").toUpperCase();
      el.classList.remove("a33-pill-sugerido", "a33-pill-editado", "a33-pill-ok");
      if (s === "OK") {
        el.textContent = "OK";
        el.classList.add("a33-pill-ok");
      } else if (s === "EDITADO") {
        el.textContent = "EDITADO";
        el.classList.add("a33-pill-editado");
      } else {
        el.textContent = "SUGERIDO";
        el.classList.add("a33-pill-sugerido");
      }
    }

    function normalizarCodigoLote(raw) {
      // Can√≥nico para identidad estable (compat Lotes): trim + upper + sin espacios
      return String(raw || "").trim().toUpperCase().replace(/\s+/g, "");
    }

    function validarCodigoLoteFuerte(raw) {
      const code = normalizarCodigoLote(raw);
      // A33 + 4 (0-9/X) + DD + MMM + YYYY
      if (!/^A33[0-9X]{4}\d{2}[A-Z]{3}\d{4}$/.test(code)) {
        return {
          ok: false,
          code,
          seq: null,
          msg: "C√≥digo inv√°lido. Formato: A33 + 4 (0-9/X) + DD + MES(3 letras) + AAAA(4). Ej: A330XX119TEV5786. Ojo: d√≠a siempre 2 d√≠gitos (03, 09)."
        };
      }
      const dd = parseInt(code.slice(7, 9), 10);
      if (!(dd >= 1 && dd <= 31)) {
        return { ok: false, code, seq: null, msg: "C√≥digo inv√°lido: el d√≠a debe ser 01‚Äì31 (2 d√≠gitos)." };
      }
      const seq = extraerSeqDeCodigo(code);
      if (!(typeof seq === "number" && seq > 0)) {
        return { ok: false, code, seq: null, msg: "C√≥digo inv√°lido: el consecutivo (los 4 despu√©s de A33) debe iniciar con n√∫mero y usar X solo como eco." };
      }
      return { ok: true, code, seq, msg: "" };
    }

    function existeCodigoEnLotes(lotes, codeUpper) {
      const c = normalizarCodigoLote(codeUpper);
      return (Array.isArray(lotes) ? lotes : []).some(l => normalizarCodigoLote(l && (l.codigo || l.code || l.lote || "")) === c);
    }

    function proponerSiguienteCodigoDisponible(baseCode, lotes) {
      const v = validarCodigoLoteFuerte(baseCode);
      const used = new Set();
      (Array.isArray(lotes) ? lotes : []).forEach(l => {
        const c = normalizarCodigoLote(l && (l.codigo || l.code || l.lote || ""));
        const n = extraerSeqDeCodigo(c);
        if (typeof n === "number" && n > 0) used.add(n);
      });
      const last = obtenerUltimoConsecutivoNumerico();
      let start = last + 1;
      if (v.ok && typeof v.seq === "number") start = Math.max(last + 1, v.seq + 1);
      const next = buscarSiguienteDisponible(start, used);
      const seq4 = pad4(next).slice(-4);
      const mask = ecoMaskX(seq4);
      const dd2 = v.ok ? v.code.slice(7, 9) : pad2(new Date().getDate());
      const hm3 = v.ok ? v.code.slice(9, 12) : (A33Hebreo.hm3 || "TEV");
      const hy4 = v.ok ? v.code.slice(12, 16) : (A33Hebreo.hy4 || String(new Date().getFullYear()).slice(-4));
      return "A33" + mask + dd2 + hm3 + hy4;
    }

    function A33ModalDuplicadoCodigo(nextCode) {
      return new Promise((resolve) => {
        const overlay = document.getElementById("a33-modal-dup-codigo");
        const textEl = document.getElementById("a33-modal-dup-text");
        const btnApply = document.getElementById("a33-modal-dup-aplicar");
        const btnCancel = document.getElementById("a33-modal-dup-cancelar");
        const code = normalizarCodigoLote(nextCode);

        // Fallback ultra-simple
        if (!overlay || !textEl || !btnApply || !btnCancel) {
          resolve(confirm("Este c√≥digo ya fue usado. Siguiente disponible: " + code + ". ¬øAplicar?"));
          return;
        }

        textEl.innerHTML = "Este c√≥digo ya fue usado. Siguiente disponible: <span class='a33-mono'>" +
          escapeHtml(code) + "</span>. ¬øAplicar?";

        const prevOverflow = document.body.style.overflow;
        overlay.hidden = false;
        overlay.setAttribute("aria-hidden", "false");
        document.body.style.overflow = "hidden";

        const cleanup = (val) => {
          overlay.hidden = true;
          overlay.setAttribute("aria-hidden", "true");
          document.body.style.overflow = prevOverflow;
          btnApply.removeEventListener("click", onApply);
          btnCancel.removeEventListener("click", onCancel);
          overlay.removeEventListener("click", onOutside);
          document.removeEventListener("keydown", onKey);
          resolve(val);
        };

        const onApply = (e) => { e.preventDefault(); cleanup(true); };
        const onCancel = (e) => { e.preventDefault(); cleanup(false); };
        const onOutside = (e) => { if (e.target === overlay) cleanup(false); };
        const onKey = (e) => { if (e.key === "Escape") cleanup(false); };

        btnApply.addEventListener("click", onApply);
        btnCancel.addEventListener("click", onCancel);
        overlay.addEventListener("click", onOutside);
        document.addEventListener("keydown", onKey);

        setTimeout(() => { try { btnApply.focus(); } catch (e) {} }, 0);
      });
    }




    function hoyLocalISO(){
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }


    function invParseNumber(value) {
      const n = parseFloat(String(value).replace(",", "."));
      return Number.isNaN(n) ? 0 : n;
    }

    function invDefault() {
      return {
        liquids: {
          vino:   { stock: 0, max: 0 },
          vodka:  { stock: 0, max: 0 },
          jugo:   { stock: 0, max: 0 },
          sirope: { stock: 0, max: 0 },
          agua:   { stock: 0, max: 0 }
        },
        bottles: {
          pulso: { stock: 0 },
          media: { stock: 0 },
          djeba: { stock: 0 },
          litro: { stock: 0 },
          galon: { stock: 0 }
        },
        finished: {
          pulso: { stock: 0 },
          media: { stock: 0 },
          djeba: { stock: 0 },
          litro: { stock: 0 },
          galon: { stock: 0 }
        },
        // Tapas (Auto) ‚Äî Etapa 2/3
        caps: {
          gallon: { stock: 0, min: 0 },
          pulsoLitro: { stock: 0, min: 0 },
          djebaMedia: { stock: 0, min: 0 }
        }
      };
    }

    function invLoad() {
      try {
        // Contrato compartido (anti-pisadas + data vieja segura)
        if (window.A33Storage && typeof A33Storage.sharedGet === 'function'){
          const data = A33Storage.sharedGet(STORAGE_KEY_INVENTARIO, invDefault());
          if (data && typeof data === 'object') return data;
          return invDefault();
        }

        // Fallback legacy
        const raw = A33Storage.getItem(STORAGE_KEY_INVENTARIO);
        let data = raw ? JSON.parse(raw) : null;
        if (!data || typeof data !== "object") data = invDefault();
        if (!data.liquids) data.liquids = {};
        if (!data.bottles) data.bottles = {};
        if (!data.finished) data.finished = {};
        if (!data.caps || typeof data.caps !== 'object') data.caps = {};
        const d = invDefault();
        Object.keys(d.liquids).forEach((k) => {
          if (!data.liquids[k]) data.liquids[k] = { stock: 0, max: 0 };
          data.liquids[k].stock = invParseNumber(data.liquids[k].stock || 0);
          data.liquids[k].max = invParseNumber(data.liquids[k].max || 0);
        });
        Object.keys(d.bottles).forEach((k) => {
          if (!data.bottles[k]) data.bottles[k] = { stock: 0 };
          data.bottles[k].stock = invParseNumber(data.bottles[k].stock || 0);
        });
        Object.keys(d.finished || {}).forEach((k) => {
          if (!data.finished[k]) data.finished[k] = { stock: 0 };
          data.finished[k].stock = invParseNumber(data.finished[k].stock || 0);
        });

        // Tapas (Auto): compatibilidad y n√∫meros seguros
        Object.keys(d.caps || {}).forEach((k) => {
          if (!data.caps[k] || typeof data.caps[k] !== 'object') data.caps[k] = { stock: 0, min: 0 };
          data.caps[k].stock = Math.trunc(invParseNumber(data.caps[k].stock || 0));
          data.caps[k].min = Math.max(0, Math.trunc(invParseNumber(data.caps[k].min || 0)));
        });
        return data;
      } catch (e) {
        console.warn("No se pudo leer inventario, usando valores por defecto.", e);
        return invDefault();
      }
    }

    function invSave(inv) {
      try {
        if (window.A33Storage && typeof A33Storage.sharedSet === 'function'){
          const r = A33Storage.sharedSet(STORAGE_KEY_INVENTARIO, inv, { source: 'calculadora' });
          if (r && r.ok === false && r.message){
            try{ alert(r.message); }catch(_){ }
          }
          return;
        }
        A33Storage.setItem(STORAGE_KEY_INVENTARIO, JSON.stringify(inv));
      } catch (e) {
        console.warn("No se pudo guardar el inventario.", e);
      }
    }

    function invBuildAlertLines(inv) {
      const lines = [];
      // L√≠quidos por debajo de 20 %
      Object.entries(inv.liquids || {}).forEach(([id, info]) => {
        const stock = invParseNumber(info.stock);
        const max = invParseNumber(info.max);
        if (max > 0) {
          const pct = (stock / max) * 100;
          if (pct <= 20) {
            let nombre = id;
            if (id === "vino") nombre = "Vino";
            if (id === "vodka") nombre = "Vodka";
            if (id === "jugo") nombre = "Jugo";
            if (id === "sirope") nombre = "Sirope";
            if (id === "agua") nombre = "Agua pura";
            lines.push("‚Ä¢ " + nombre + ": " + stock.toFixed(0) + " ml (" + pct.toFixed(1) + "% restante)");
          }
        }
      });
      // Botellas con 10 o menos unidades
      Object.entries(inv.bottles || {}).forEach(([id, info]) => {
        const stock = invParseNumber(info.stock);
        if (stock <= 10) {
          let nombre = id;
          if (id === "pulso") nombre = "Pulso 250 ml";
          if (id === "media") nombre = "Media 375 ml";
          if (id === "djeba") nombre = "Djeba 750 ml";
          if (id === "litro") nombre = "Litro 1000 ml";
          if (id === "galon") nombre = "Gal√≥n 3750 ml";
          lines.push("‚Ä¢ " + nombre + ": " + stock.toFixed(0) + " botellas");
        }
      });
      // Producto terminado con 10 o menos unidades
      Object.entries(inv.finished || {}).forEach(([id, info]) => {
        const stock = invParseNumber(info.stock);
        if (stock <= 10) {
          let nombre = id;
          if (id === "pulso") nombre = "Pulso 250 ml listo";
          if (id === "media") nombre = "Media 375 ml lista";
          if (id === "djeba") nombre = "Djeba 750 ml lista";
          if (id === "litro") nombre = "Litro 1000 ml listo";
          if (id === "galon") nombre = "Gal√≥n 3750 ml listo";
          lines.push("‚Ä¢ " + nombre + ": " + stock.toFixed(0) + " botellas listas");
        }
      });
      return lines;
    }

    function aplicarConsumoInventarioDesdeLote(datos, mapUnits) {
      if (!datos || !datos.totalesIngredientes) return true;

      // Leer con meta (anti-pisadas)
      let invInfo = null;
      let inv = null;
      try {
        if (window.A33Storage && typeof A33Storage.sharedRead === 'function') {
          invInfo = A33Storage.sharedRead(STORAGE_KEY_INVENTARIO, invDefault());
          inv = (invInfo && invInfo.data && typeof invInfo.data === "object") ? invInfo.data : invDefault();
        } else {
          inv = invLoad();
        }
      } catch (e) {
        inv = invDefault();
      }

      // Restar l√≠quidos
      ["vino","vodka","jugo","sirope","agua"].forEach((ing) => {
        const uso = typeof datos.totalesIngredientes[ing] === "number" ? datos.totalesIngredientes[ing] : 0;
        if (!inv.liquids[ing]) {
          inv.liquids[ing] = { stock: 0, max: 0 };
        }
        inv.liquids[ing].stock = invParseNumber(inv.liquids[ing].stock) - uso;
      });

      // Restar botellas por presentaci√≥n
      // Tapas (Auto) ‚Äî Etapa 3/3 (descuento autom√°tico al producir)
      if (!inv.caps || typeof inv.caps !== 'object') {
        inv.caps = {
          gallon: { stock: 0, min: 0 },
          pulsoLitro: { stock: 0, min: 0 },
          djebaMedia: { stock: 0, min: 0 }
        };
      }
      ["gallon", "pulsoLitro", "djebaMedia"].forEach((k) => {
        if (!inv.caps[k] || typeof inv.caps[k] !== 'object') inv.caps[k] = { stock: 0, min: 0 };
        // stock: entero (permitir negativo)
        inv.caps[k].stock = Math.trunc(invParseNumber(inv.caps[k].stock));
        // min: entero >= 0 (por compat UI)
        inv.caps[k].min = Math.max(0, Math.trunc(invParseNumber(inv.caps[k].min)));
      });

      const map = mapUnits || {};
      PRESENTACIONES.forEach((p) => {
        const qty = normQtyInt(map[p.id]);
        if (qty <= 0) return;
        if (!inv.bottles[p.id]) {
          inv.bottles[p.id] = { stock: 0 };
        }
        inv.bottles[p.id].stock = invParseNumber(inv.bottles[p.id].stock) - qty;

        // Sumar producto terminado (botellas listas)
        if (!inv.finished) inv.finished = {};
        if (!inv.finished[p.id]) {
          inv.finished[p.id] = { stock: 0 };
        }
        inv.finished[p.id].stock = invParseNumber(inv.finished[p.id].stock) + qty;

        // Descontar tapa por unidad producida seg√∫n mapping fijo
        if (qty > 0) {
          let capId = null;
          if (p.id === 'galon') capId = 'gallon';
          else if (p.id === 'pulso' || p.id === 'litro') capId = 'pulsoLitro';
          else if (p.id === 'djeba' || p.id === 'media') capId = 'djebaMedia';

          if (capId) {
            const before = Math.trunc(invParseNumber(inv.caps[capId] && inv.caps[capId].stock));
            const after = before - qty;
            inv.caps[capId].stock = after;
            // Log m√≠nimo (no spam): una l√≠nea por presentaci√≥n producida
            console.info('[A33][CAPS] producir', p.id, p.nombre, 'qty', qty, '=>', capId, before, '‚Üí', after);
          }
        }
      });

      // Guardado conservador: bloquear si cambi√≥ entre lectura y escritura
      if (window.A33Storage && typeof A33Storage.sharedSet === 'function' && invInfo && invInfo.meta && typeof invInfo.meta.rev === "number") {
        const r = A33Storage.sharedSet(STORAGE_KEY_INVENTARIO, inv, { source: 'calculadora', baseRev: invInfo.meta.rev, conflictPolicy: 'block' });
        if (r && r.ok === false) throw new Error(r.message || "Conflicto detectado: Inventario cambi√≥ en otro m√≥dulo/pesta√±a.");
      } else {
        invSave(inv);
      }

      const lines = invBuildAlertLines(inv);
      if (lines.length > 0) {
        alert("Alerta de inventario (despu√©s de registrar el lote):\n\n" + lines.join("\n"));
      }

      return true;
    }



    function getNumberValue(id) {
      const el = document.getElementById(id);
      if (!el) return 0;
      const raw = (el.value || "").toString().replace(",", ".");
      const v = parseFloat(raw);
      return isNaN(v) ? 0 : v;
    }

    // qty: entero > 0 (normalizar).
    function normQtyInt(value) {
      const n = (typeof value === 'number') ? value : parseFloat(String(value ?? '').replace(',', '.'));
      if (!Number.isFinite(n)) return 0;
      const q = Math.trunc(n);
      return q > 0 ? q : 0;
    }
    function formatMl(value) {
      return value.toFixed(0) + " ml";
    }
    function formatLitros(valueMl) {
      const litros = valueMl / 1000;
      return litros.toFixed(2) + " L";
    }
    function escapeHtml(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }
    function slugify(text) {
      return text
        .toString()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "")
        .substring(0, 40) || "arcano33";
    }
    function formatearFechaBonita(date) {
      if (!date) return "";
      const d = date.getDate().toString().padStart(2, "0");
      const m = (date.getMonth() + 1).toString().padStart(2, "0");
      const y = date.getFullYear();
      return d + "/" + m + "/" + y;
    }
    function calcularCaducidad(fechaProdStr) {
      if (!fechaProdStr) return null;
      const partes = fechaProdStr.split("-");
      if (partes.length !== 3) return null;
      const year = parseInt(partes[0], 10);
      const month = parseInt(partes[1], 10) - 1;
      const day = parseInt(partes[2], 10);
      if (isNaN(year) || isNaN(month) || isNaN(day)) return null;
      const fecha = new Date(year, month, day);
      if (isNaN(fecha.getTime())) return null;
      const cad = new Date(fecha);
      cad.setMonth(cad.getMonth() + 2);
      return cad;
    }
    function actualizarTextoCaducidad() {
      const fechaProdInput = document.getElementById("fecha-produccion");
      const textoCad = document.getElementById("texto-caducidad");
      const badgeCad = document.getElementById("badge-caducidad");
      const valor = (fechaProdInput && fechaProdInput.value) ? fechaProdInput.value : "";
      const cad = calcularCaducidad(valor);

      if (!valor) {
        if (textoCad) textoCad.textContent = "Fecha de caducidad: ‚Äî";
        if (badgeCad) badgeCad.textContent = "Caducidad: Calcula para ver‚Ä¶";
      } else if (!cad) {
        if (textoCad) textoCad.textContent = "Fecha de caducidad: (fecha de producci√≥n no v√°lida)";
        if (badgeCad) badgeCad.textContent = "Caducidad: (fecha no v√°lida)";
      } else {
        const pretty = formatearFechaBonita(cad);
        if (textoCad) textoCad.textContent = "Fecha de caducidad: " + pretty;
        if (badgeCad) badgeCad.textContent = "Caducidad: " + pretty;
      }
    }
    // Etapa 3: Hebreo offline-first (Intl -> cache local -> degradaci√≥n controlada + fetch opcional no bloqueante)
    const STORAGE_HEB_CACHE_KEY = "a33_calc_hebrew_cache_v1";
    const HEB_FETCH_TIMEOUT_MS = 2500;
    let A33HebreoFetch = { inFlight: false, iso: "", abort: null };

    function leerHebreoCacheObj() {
      try {
        const raw = A33Storage.getItem(STORAGE_HEB_CACHE_KEY);
        const obj = raw ? JSON.parse(raw) : null;
        if (!obj || typeof obj !== "object") return { v: 1, order: [], items: {} };
        if (obj.v !== 1 || !obj.items || typeof obj.items !== "object" || !Array.isArray(obj.order)) {
          return { v: 1, order: [], items: {} };
        }
        return obj;
      } catch (e) {
        return { v: 1, order: [], items: {} };
      }
    }

    function leerHebreoCache(iso) {
      const key = String(iso || "").trim();
      if (!key) return null;
      const cache = leerHebreoCacheObj();
      const h = cache.items[key];
      if (h && h.hd && h.hm && h.hy && h.hm3 && h.hy4) return h;
      return null;
    }

    function guardarHebreoCache(iso, h) {
      const key = String(iso || "").trim();
      if (!key || !h || !h.hd || !h.hm || !h.hy || !h.hm3 || !h.hy4) return;
      try {
        const cache = leerHebreoCacheObj();
        cache.items[key] = h;
        cache.order = cache.order.filter(x => x !== key);
        cache.order.push(key);
        // l√≠mite simple para no inflar storage
        const MAX = 120;
        while (cache.order.length > MAX) {
          const old = cache.order.shift();
          if (old) delete cache.items[old];
        }
        A33Storage.setItem(STORAGE_HEB_CACHE_KEY, JSON.stringify(cache));
      } catch (e) {
        // silencioso
      }
    }

    function obtenerHebreaLocalDesdeFechaISO(iso) {
      const dt = parseISODateLocal(iso);
      if (!dt) return null;
      try {
        // Safari/iOS suele soportarlo; si no, lanzar√° RangeError.
        const fmt = new Intl.DateTimeFormat("en-u-ca-hebrew-nu-latn", { day: "numeric", month: "long", year: "numeric" });
        const parts = fmt.formatToParts(dt);
        const hd = (((parts.find(p => p.type === "day") || {}).value || "").match(/\d+/) || [""])[0] || "";
        const hm = ((parts.find(p => p.type === "month") || {}).value || "").trim();
        const hy = (((parts.find(p => p.type === "year") || {}).value || "").match(/\d+/) || [""])[0] || "";
        const hm3 = sanitizeMonth3(hm);
        const hy4 = hy ? hy.slice(-4) : "";
        if (hd && hm && hm3.length === 3 && hy4.length === 4) {
          return { hd, hm, hy: hy4, hm3, hy4 };
        }
      } catch (e) {
        return null;
      }
      return null;
    }

    async function obtenerHebreaOnlineHebcal(iso, signal) {
      const dt = parseISODateLocal(iso);
      if (!dt) return null;
      try {
        const y = dt.getFullYear();
        const m = dt.getMonth() + 1;
        const d = dt.getDate();
        const url = "https://www.hebcal.com/converter?cfg=json&g2h=1&gy=" + y + "&gm=" + m + "&gd=" + d + "&lang=en";
        const res = await fetch(url, { signal });
        if (!res.ok) return null;
        const data = await res.json();
        if (data && typeof data.hd !== "undefined" && data.hm && data.hy) {
          const hd = (String(data.hd).match(/\d+/) || [""])[0] || "";
          const hm = String(data.hm || "").trim();
          const hy = (String(data.hy).match(/\d+/) || [""])[0] || "";
          const hm3 = sanitizeMonth3(hm);
          const hy4 = hy ? hy.slice(-4) : "";
          if (hd && hm && hm3.length === 3 && hy4.length === 4) {
            return { hd, hm, hy: hy4, hm3, hy4 };
          }
        }
      } catch (e) {
        return null;
      }
      return null;
    }

    function intentarHebcalBackground(iso) {
      // NO bloqueante: si llega, actualiza UI + cache. Si no, no pasa nada.
      const key = String(iso || "").trim();
      if (!key) return;
      if (A33HebreoFetch.inFlight && A33HebreoFetch.iso === key) return;

      // cancelar anterior si existe
      try { if (A33HebreoFetch.abort) A33HebreoFetch.abort.abort(); } catch (e) {}

      const controller = (typeof AbortController !== "undefined") ? new AbortController() : null;
      A33HebreoFetch = { inFlight: true, iso: key, abort: controller };

      const done = (h) => {
        A33HebreoFetch.inFlight = false;
        const prodNow = (document.getElementById("fecha-produccion") && document.getElementById("fecha-produccion").value) || "";
        if (String(prodNow).trim() !== key) return; // el usuario cambi√≥ la fecha
        if (h && h.hd && h.hm && h.hy) {
          guardarHebreoCache(key, h);
          A33Hebreo = h;
          const pretty = h.hd + " " + h.hm + " " + h.hy;
          const span = document.getElementById("texto-fecha-hebreo");
          const badgeHeb = document.getElementById("badge-hebreo");
          if (span) span.textContent = "Fecha hebrea (producci√≥n): " + pretty;
          if (badgeHeb) badgeHeb.textContent = "Hebreo: " + pretty;
          // si estamos en AUTO, recalculamos el c√≥digo sugerido sin tocar consecutivo
          if (A33CodigoLoteMode === "AUTO") {
            recalcularCodigoLoteAuto({ force: false });
          }
        }
      };

      // timeout duro
      let t = null;
      if (controller) {
        t = setTimeout(() => {
          try { controller.abort(); } catch (e) {}
        }, HEB_FETCH_TIMEOUT_MS);
      }

      obtenerHebreaOnlineHebcal(key, controller ? controller.signal : undefined)
        .then(h => {
          if (t) clearTimeout(t);
          done(h);
        })
        .catch(() => {
          if (t) clearTimeout(t);
          A33HebreoFetch.inFlight = false;
        });
    }

    function actualizarFechaHebrea() {
      // Deriva SIEMPRE de la fecha de producci√≥n.
      const span = document.getElementById("texto-fecha-hebreo");
      const badgeHeb = document.getElementById("badge-hebreo");
      if (!span) return Promise.resolve(null);

      const prod = (document.getElementById("fecha-produccion") && document.getElementById("fecha-produccion").value) || "";
      const iso = String(prod || "").trim();

      // Sin fecha de producci√≥n: placeholder claro (no usar "hoy" para no confundir).
      if (!iso) {
        A33Hebreo = { hd:"", hm:"", hy:"", hm3:"", hy4:"" };
        span.textContent = "Fecha hebrea (producci√≥n): ‚Äî";
        if (badgeHeb) badgeHeb.textContent = "Hebreo: Calcula para ver‚Ä¶";
        return Promise.resolve(null);
      }

      // 1) Local (offline-first)
      const local = obtenerHebreaLocalDesdeFechaISO(iso);
      if (local && local.hd && local.hm && local.hy) {
        A33Hebreo = local;
        guardarHebreoCache(iso, local);
        const pretty = local.hd + " " + local.hm + " " + local.hy;
        span.textContent = "Fecha hebrea (producci√≥n): " + pretty;
        if (badgeHeb) badgeHeb.textContent = "Hebreo: " + pretty;
        return Promise.resolve(local);
      }

      // 2) Cache local (si ya lo vimos alguna vez)
      const cached = leerHebreoCache(iso);
      if (cached && cached.hd && cached.hm && cached.hy) {
        A33Hebreo = cached;
        const pretty = cached.hd + " " + cached.hm + " " + cached.hy;
        span.textContent = "Fecha hebrea (producci√≥n): " + pretty;
        if (badgeHeb) badgeHeb.textContent = "Hebreo: " + pretty;
        return Promise.resolve(cached);
      }

      // 3) Degradaci√≥n controlada: NO romper flujo
      A33Hebreo = { hd:"", hm:"", hy:"", hm3:"", hy4:"" };
      span.textContent = "Fecha hebrea (producci√≥n): Fecha hebrea no disponible offline";
      if (badgeHeb) badgeHeb.textContent = "Hebreo: Fecha hebrea no disponible offline";

      // 4) Fetch opcional (no bloqueante) solo si hay red
      try {
        if (typeof navigator !== "undefined" && navigator.onLine) {
          intentarHebcalBackground(iso);
        }
      } catch (e) {}

      return Promise.resolve(null);
    }

    function parseISODateLocal(iso) {
      // Evitar que new Date('YYYY-MM-DD') se interprete como UTC.
      try {
        const parts = String(iso || "").split("-");
        if (parts.length !== 3) return null;
        const y = parseInt(parts[0], 10);
        const m = parseInt(parts[1], 10);
        const d = parseInt(parts[2], 10);
        if (!y || !m || !d) return null;
        return new Date(y, m - 1, d);
      } catch (e) {
        return null;
      }
    }

    function pad2(n) {
      return String(n).padStart(2, "0");
    }
    function pad4(n) {
      return String(n).padStart(4, "0");
    }

    function ecoMaskX(seq4) {
      const s = String(seq4 || "");
      if (!/^\d{4}$/.test(s)) return s;
      let out = s[0];
      for (let i = 1; i < s.length; i++) {
        // comparar contra el d√≠gito REAL anterior (eco)
        out += (s[i] === s[i - 1]) ? "X" : s[i];
      }
      return out;
    }

    function sanitizeMonth3(name) {
      const letters = String(name || "").toUpperCase().replace(/[^A-Z]/g, "");
      return letters.slice(0, 3);
    }

    // Nota: obtenerHebreaDesdeFechaISO se reemplaz√≥ por la estrategia Etapa 3 (local + cache + degradaci√≥n + fetch no bloqueante).

    function ecoUnmaskX(mask4) {
      const s = String(mask4 || "");
      if (!/^[0-9X]{4}$/.test(s)) return null;
      if (!/^\d/.test(s)) return null;
      let out = s[0];
      for (let i = 1; i < 4; i++) {
        const ch = s[i];
        out += (ch === "X") ? out[i - 1] : ch;
      }
      if (!/^\d{4}$/.test(out)) return null;
      return out;
    }

    function extraerSeqDeCodigo(code) {
      const s = String(code || "").trim();
      if (!s.startsWith("A33") || s.length < 7) return null;
      const mask = s.slice(3, 7);
      const un = ecoUnmaskX(mask);
      if (!un) return null;
      const n = parseInt(un, 10);
      return Number.isFinite(n) ? n : null;
    }

    function leerUltimoConsecutivoKey() {
      try {
        const raw = A33Storage.getItem(STORAGE_LOTE_SEQ_LAST_KEY);
        const n = parseInt(String(raw || "0"), 10) || 0;
        return Number.isFinite(n) ? n : 0;
      } catch (e) {
        return 0;
      }
    }

    function obtenerMaxSeqDesdeLotes() {
      let max = 0;
      try {
        const arr = (window.A33Storage && typeof A33Storage.sharedGet === 'function')
          ? A33Storage.sharedGet("arcano33_lotes", [])
          : (() => { const raw = A33Storage.getItem("arcano33_lotes"); return raw ? JSON.parse(raw) : []; })();
        if (!Array.isArray(arr)) return 0;
        arr.forEach(l => {
          const c = l && (l.codigo || l.code || l.lote || "");
          const n = extraerSeqDeCodigo(c);
          if (typeof n === "number" && n > max) max = n;
        });
      } catch (e) {}
      return max;
    }

    function obtenerUsedSeqSetDesdeLotes() {
      const set = new Set();
      try {
        const arr = (window.A33Storage && typeof A33Storage.sharedGet === 'function')
          ? A33Storage.sharedGet("arcano33_lotes", [])
          : (() => { const raw = A33Storage.getItem("arcano33_lotes"); return raw ? JSON.parse(raw) : []; })();
        if (!Array.isArray(arr)) return set;
        arr.forEach(l => {
          const c = l && (l.codigo || l.code || l.lote || "");
          const n = extraerSeqDeCodigo(c);
          if (typeof n === "number" && n > 0) set.add(n);
        });
      } catch (e) {}
      return set;
    }

    function obtenerUltimoConsecutivoNumerico() {
      return Math.max(leerUltimoConsecutivoKey(), obtenerMaxSeqDesdeLotes());
    }

    function buscarSiguienteDisponible(desde, usedSet) {
      let n = desde;
      const safeMax = 9999;
      let loops = 0;
      while (usedSet && usedSet.has(n) && loops < 11000 && n <= safeMax) {
        n++;
        loops++;
      }
      if (n > safeMax) {
        console.warn("Consecutivo excedi√≥ 9999; revisa tus lotes.");
        n = safeMax;
      }
      return n;
    }

    function sugerirSeq4(opts) {
      const advance = !!(opts && opts.advance);
      const used = obtenerUsedSeqSetDesdeLotes();
      const last = obtenerUltimoConsecutivoNumerico();
      let n = 0;
      if (/^\d{4}$/.test(String(A33AutoSeq || ""))) {
        n = parseInt(A33AutoSeq, 10) || 0;
        if (advance) n++;
      } else {
        n = last + 1;
      }
      // Nunca quedarnos atr√°s
      if (n <= last) n = last + 1;
      n = buscarSiguienteDisponible(n, used);
      return pad4(n).slice(-4);
    }

    function commitConsecutivoDespuesDeGuardar(code, seqHint) {
      const last = obtenerUltimoConsecutivoNumerico();
      let usedSeq = (typeof seqHint === "number" && seqHint > 0) ? seqHint : extraerSeqDeCodigo(code);

      // Si por alguna raz√≥n no podemos extraer el consecutivo, NO avanzamos el contador.
      if (!(typeof usedSeq === "number" && usedSeq > 0)) {
        usedSeq = last;
      }

      const newLast = Math.max(last, usedSeq);
      const seq4 = pad4(newLast).slice(-4);
      try { A33Storage.setItem(STORAGE_LOTE_SEQ_LAST_KEY, seq4); } catch (e) {}
      // Compatibilidad: se conserva la key anterior, pero solo se actualiza al guardar exitosamente.
      try { A33Storage.setItem(STORAGE_LOTE_SEQ_CURRENT_KEY, seq4); } catch (e) {}
      return seq4;
    }


    function setCodigoLoteValue(v) {
      const loteInput = document.getElementById("lote");
      if (!loteInput) return;
      A33SuppressCodigoInput = true;
      loteInput.value = v || "";
      // liberar en el siguiente tick para evitar marcar MANUAL por set program√°tico
      setTimeout(() => { A33SuppressCodigoInput = false; }, 0);
    }

    function marcarCodigoComoManual() {
      A33CodigoLoteMode = "MANUAL";
      try { A33Storage.setItem(STORAGE_LOTE_CODE_MODE_KEY, "MANUAL"); } catch (e) {}
      setPillEstadoCodigo("EDITADO");
    }
async function recalcularCodigoLoteAuto(opts) {
      // PREVIEW: generar/actualizar el c√≥digo sin comprometer consecutivo.
      // Nota: por compatibilidad puede venir opts.consumeNewSeq, pero se ignora (NO se avanza por recalcular).
      const force = !!(opts && (opts.force || opts.forceNewPreview));

      if (force || !/^\d{4}$/.test(String(A33AutoSeq || ""))) {
        // El preview siempre parte del √∫ltimo comprometido + 1 (o el siguiente libre), pero NO lo guarda como consecutivo.
        A33AutoSeq = sugerirSeq4({ advance: false });
      }

      A33CodigoLoteMode = "AUTO";
      try { A33Storage.setItem(STORAGE_LOTE_CODE_MODE_KEY, "AUTO"); } catch (e) {}

      const fechaProdIso = ((document.getElementById("fecha-produccion") && document.getElementById("fecha-produccion").value) || hoyLocalISO()).trim();
      const dt = parseISODateLocal(fechaProdIso) || new Date();

      const heb = await actualizarFechaHebrea(); // Etapa 3: resuelve r√°pido (sin bloquear por red)
      const heb2 = (heb && heb.hd && heb.hm3 && heb.hy4) ? heb : (leerHebreoCache(fechaProdIso) || null);

      // D√≠a SIEMPRE desde la misma fuente hebrea (si existe). Fallback controlado: gregoriano.
      const dia2 = pad2((heb2 && heb2.hd) ? heb2.hd : dt.getDate());
      const hm3 = (heb2 && heb2.hm3) ? heb2.hm3 : "OFF";
      const hy4 = (heb2 && heb2.hy4) ? heb2.hy4 : String(dt.getFullYear()).slice(-4);

      const consecMask = ecoMaskX(A33AutoSeq);
      const code = "A33" + consecMask + dia2 + hm3 + hy4;

      if (!/^A33[A-Z0-9X]{4}\d{2}[A-Z]{3}\d{4}$/.test(code)) {
        console.warn("C√≥digo de lote generado inv√°lido:", code);
        return;
      }

      setCodigoLoteValue(code);
      setPillEstadoCodigo("SUGERIDO");
      A33SuggestedCode = code;

      // Persistimos el valor actual del input (compatibilidad), pero NO el consecutivo.
      try { A33Storage.setItem(STORAGE_LOTE_KEY, code); } catch (e) {}
    }


    function construirTablaRecetas() {
      const tbody = document.querySelector("#recetas-table tbody");
      tbody.innerHTML = "";
      PRESENTACIONES.forEach(p => {
        const tr = document.createElement("tr");
        const tdNombre = document.createElement("td");
        tdNombre.textContent = p.nombre;
        tdNombre.style.textAlign = "left";
        tr.appendChild(tdNombre);
        INGREDIENTES.forEach(ing => {
          const td = document.createElement("td");
          const input = document.createElement("input");
          input.type = "number";
          input.min = "0";
          input.step = "0.01";
          input.id = "receta-" + p.id + "-" + ing;
          input.placeholder = "0";
          td.appendChild(input);
          tr.appendChild(td);
        });
        // columna de costo unitario por presentaci√≥n
        const tdCosto = document.createElement("td");
        const inputCosto = document.createElement("input");
        inputCosto.type = "number";
        inputCosto.min = "0";
        inputCosto.step = "0.01";
        inputCosto.id = "costo-unit-" + p.id;
        inputCosto.placeholder = "0";
        tdCosto.appendChild(inputCosto);
        tr.appendChild(tdCosto);

        tbody.appendChild(tr);
      });
    }

    function construirTablaPlan() {
      const tbody = document.querySelector("#plan-table tbody");
      tbody.innerHTML = "";
      PRESENTACIONES.forEach(p => {
        const tr = document.createElement("tr");
        const tdNombre = document.createElement("td");
        tdNombre.textContent = p.nombre;
        tdNombre.style.textAlign = "left";
        tr.appendChild(tdNombre);
        const tdCantidad = document.createElement("td");
        const input = document.createElement("input");
        input.type = "number";
        input.min = "0";
        input.step = "1";
        input.id = "plan-" + p.id;
        input.placeholder = "0";
        tdCantidad.appendChild(input);
        tr.appendChild(tdCantidad);
        tbody.appendChild(tr);
      });
    }
    function guardarRecetas() {
      const recetas = {};
      const costosPresentacion = {};
      PRESENTACIONES.forEach(p => {
        recetas[p.id] = {};
        INGREDIENTES.forEach(ing => {
          const val = getNumberValue("receta-" + p.id + "-" + ing);
          recetas[p.id][ing] = val;
        });
        const costoUnit = getNumberValue("costo-unit-" + p.id);
        costosPresentacion[p.id] = {
          id: p.id,
          nombre: p.nombre,
          costoUnidad: costoUnit
        };
      });
      const payload = {
        version: 2,
        recetas,
        costosPresentacion
      };
      try{
        if (window.A33Storage && typeof A33Storage.sharedSet === 'function'){
          const r = A33Storage.sharedSet(STORAGE_RECETAS_KEY, payload, { source: 'calculadora' });
          if (r && r.ok === false && r.message){
            alert(r.message);
            return;
          }
        } else {
          A33Storage.setItem(STORAGE_RECETAS_KEY, JSON.stringify(payload));
        }
      }catch(e){
        console.warn('No se pudo guardar recetas:', e);
      }
      alert("Recetas y costos guardados en este navegador ‚úÖ");
    }

    function cargarRecetas() {
      // Contrato compartido (anti-pisadas + data vieja segura)
      try {
        let data = null;
        if (window.A33Storage && typeof A33Storage.sharedGet === 'function'){
          data = A33Storage.sharedGet(STORAGE_RECETAS_KEY, null);
        } else {
          const raw = A33Storage.getItem(STORAGE_RECETAS_KEY);
          data = raw ? JSON.parse(raw) : null;
        }
        if (!data) return;
        const recetas = data && data.recetas ? data.recetas : data;
        const costosPresentacion = data && data.costosPresentacion ? data.costosPresentacion : null;

        // cargar recetas (ml)
        PRESENTACIONES.forEach(p => {
          const rec = recetas[p.id];
          if (!rec) return;
          INGREDIENTES.forEach(ing => {
            const input = document.getElementById("receta-" + p.id + "-" + ing);
            if (!input) return;
            const val = rec[ing];
            if (typeof val === "number") {
              input.value = val;
            }
          });
        });

        // cargar costos por presentaci√≥n si existen
        if (costosPresentacion) {
          PRESENTACIONES.forEach(p => {
            const info = costosPresentacion[p.id];
            if (!info) return;
            const inputCosto = document.getElementById("costo-unit-" + p.id);
            if (inputCosto && typeof info.costoUnidad === "number") {
              inputCosto.value = info.costoUnidad;
            }
          });
        }
      } catch (e) {
        console.warn("Error cargando recetas:", e);
      }
    }

    function resetNotasAlEntrar() {
      const notasInput = document.getElementById("notas");
      if (!notasInput) return;
      // UI + estado interno: siempre vac√≠o al entrar (incluye BFCache/pageshow).
      notasInput.value = "";
      try { A33Storage.removeItem(STORAGE_NOTAS_KEY); } catch (e) {}
    }

    function guardarMetaLote() {
      const loteInput = document.getElementById("lote");
      const fechaProdInput = document.getElementById("fecha-produccion");
      if (loteInput) {
        A33Storage.setItem(STORAGE_LOTE_KEY, loteInput.value || "");
      }
      // Persistimos solo el modo (AUTO/MANUAL). El consecutivo se compromete √∫nicamente al guardar lote.
      try { A33Storage.setItem(STORAGE_LOTE_CODE_MODE_KEY, A33CodigoLoteMode); } catch (e) {}
      if (fechaProdInput) {
        // En Calculadora no se editan registros existentes: no persistimos la fecha entre sesiones.
        A33Storage.removeItem(STORAGE_FECHA_PROD_KEY);
      }
      // Notas NO se persisten entre sesiones.
      try { A33Storage.removeItem(STORAGE_NOTAS_KEY); } catch (e) {}
      actualizarTextoCaducidad();
    }
    function cargarMetaLote() {
      const fechaProdInput = document.getElementById("fecha-produccion");
      if (fechaProdInput) {
        // Compatibilidad: si qued√≥ una fecha vieja guardada, la limpiamos.
        A33Storage.removeItem(STORAGE_FECHA_PROD_KEY);
        fechaProdInput.value = hoyLocalISO();
      }
      // Al entrar a Calculadora, Notas siempre empieza vac√≠a (sin tocar otros campos).
      resetNotasAlEntrar();
      A33HasCalculoPrevio = false;
      const hintRes = document.getElementById("hint-resultados");
      if (hintRes) hintRes.style.display = "block";
      actualizarTextoCaducidad();

      // Nuevo lote / nueva corrida: AUTO genera c√≥digo sugerido (preview), sin quemar consecutivo.
      A33CodigoLoteMode = "AUTO";
      A33AutoSeq = "";
      try { A33Storage.setItem(STORAGE_LOTE_CODE_MODE_KEY, "AUTO"); } catch (e) {}
      setCodigoLoteValue("");
      setPillEstadoCodigo("SUGERIDO");
      recalcularCodigoLoteAuto({ consumeNewSeq: false });
    }
    function calcularDatosLote() {
      const totalesIngredientes = { vino: 0, vodka: 0, jugo: 0, sirope: 0, agua: 0 };
      let totalVolumenFinalMl = 0;
      const unidadesPorPresentacion = [];
      PRESENTACIONES.forEach(p => {
        const unidades = normQtyInt(getNumberValue("plan-" + p.id));
        if (unidades > 0) {
          unidadesPorPresentacion.push({ id: p.id, nombre: p.nombre, unidades });
        }
        if (unidades <= 0) return;
        INGREDIENTES.forEach(ing => {
          const mlPorUnidad = getNumberValue("receta-" + p.id + "-" + ing);
          totalesIngredientes[ing] += unidades * mlPorUnidad;
        });
        totalVolumenFinalMl += unidades * p.volumenMl;
      });
      const loteNombre = (document.getElementById("lote").value || "").trim();
      const fechaProdStr = document.getElementById("fecha-produccion").value || "";
      const fechaProd = fechaProdStr ? new Date(fechaProdStr + "T00:00:00") : null;
      const fechaCad = calcularCaducidad(fechaProdStr);
      const notas = document.getElementById("notas").value || "";
      return {
        totalesIngredientes,
        totalVolumenFinalMl,
        unidadesPorPresentacion,
        loteNombre,
        fechaProd,
        fechaProdStr,
        fechaCad,
        notas
      };
    }
    function calcularTotales() {
      const datos = calcularDatosLote();
      const resultadosDiv = document.getElementById("resultados");
      const totalesDiv = document.getElementById("totales-ingredientes");
      const resumenVolumenDiv = document.getElementById("resumen-volumen");
      const resumenLoteDiv = document.getElementById("resumen-lote");
      const resumenFechasDiv = document.getElementById("resumen-fechas");

      const loteNombre = datos.loteNombre;
      let htmlLote = "";
      if (loteNombre) {
        htmlLote = "<div class='flex-row'><div class='badge'>Lote: <strong>" +
          escapeHtml(loteNombre) +
          "</strong></div></div>";
      } else {
        htmlLote = "<div class='flex-row'><div class='badge'>Lote sin nombre</div></div>";
      }
      resumenLoteDiv.innerHTML = htmlLote;

      let htmlFechas = "<div class='flex-row'>";
      if (datos.fechaProd) {
        htmlFechas += "<div class='badge'>Producci√≥n: <strong>" + formatearFechaBonita(datos.fechaProd) + "</strong></div>";
      } else {
        htmlFechas += "<div class='badge'>Producci√≥n: ‚Äî</div>";
      }
      if (datos.fechaCad) {
        htmlFechas += "<div class='badge'>Caducidad: <strong>" + formatearFechaBonita(datos.fechaCad) + "</strong></div>";
      } else {
        htmlFechas += "<div class='badge'>Caducidad: ‚Äî</div>";
      }
      if (datos.notas) {
        htmlFechas += "<div class='badge'>Notas: " + escapeHtml(datos.notas.substring(0, 60)) + (datos.notas.length > 60 ? "..." : "") + "</div>";
      }
      htmlFechas += "</div>";
      resumenFechasDiv.innerHTML = htmlFechas;

      let htmlTotales = "<table><thead><tr><th>Ingrediente</th><th>Total (ml)</th><th>Equivalente (L)</th></tr></thead><tbody>";
      htmlTotales += "<tr><td style='text-align:left;'>Vino</td><td>" + formatMl(datos.totalesIngredientes.vino) + "</td><td>" + formatLitros(datos.totalesIngredientes.vino) + "</td></tr>";
      htmlTotales += "<tr><td style='text-align:left;'>Vodka</td><td>" + formatMl(datos.totalesIngredientes.vodka) + "</td><td>" + formatLitros(datos.totalesIngredientes.vodka) + "</td></tr>";
      htmlTotales += "<tr><td style='text-align:left;'>Jugo</td><td>" + formatMl(datos.totalesIngredientes.jugo) + "</td><td>" + formatLitros(datos.totalesIngredientes.jugo) + "</td></tr>";
      htmlTotales += "<tr><td style='text-align:left;'>Sirope</td><td>" + formatMl(datos.totalesIngredientes.sirope) + "</td><td>" + formatLitros(datos.totalesIngredientes.sirope) + "</td></tr>";
      htmlTotales += "<tr><td style='text-align:left;'>Agua pura</td><td>" + formatMl(datos.totalesIngredientes.agua) + "</td><td>" + formatLitros(datos.totalesIngredientes.agua) + "</td></tr>";
      htmlTotales += "</tbody></table>";
      totalesDiv.innerHTML = htmlTotales;


      const resumenCostosDiv = document.getElementById("resumen-costos");
      if (resumenCostosDiv) {
        let costoTotal = 0;
        const filas = [];
        datos.unidadesPorPresentacion.forEach(item => {
          const costoUnit = getNumberValue("costo-unit-" + item.id);
          if (costoUnit > 0 && item.unidades > 0) {
            const subtotal = costoUnit * item.unidades;
            costoTotal += subtotal;
            filas.push({
              nombre: item.nombre,
              unidades: item.unidades,
              costoUnidad: costoUnit,
              subtotal
            });
          }
        });

        let htmlCostos = "";
        if (filas.length) {
          htmlCostos += "<div class='flex-row'>";
          htmlCostos += "<div class='badge'>Costo total estimado del lote: <strong>C$ " + costoTotal.toFixed(2) + "</strong></div>";
          if (datos.totalVolumenFinalMl > 0) {
            const costoPorLitro = costoTotal / (datos.totalVolumenFinalMl / 1000);
            htmlCostos += "<div class='badge'>Costo aprox. por litro: <strong>C$ " + costoPorLitro.toFixed(2) + "</strong></div>";
          }
          htmlCostos += "</div>";

          htmlCostos += "<table><thead><tr><th>Presentaci√≥n</th><th>Unidades</th><th>Costo unitario (C$)</th><th>Subtotal (C$)</th></tr></thead><tbody>";
          filas.forEach(f => {
            htmlCostos += "<tr>";
            htmlCostos += "<td style='text-align:left;'>" + escapeHtml(f.nombre) + "</td>";
            htmlCostos += "<td>" + f.unidades + "</td>";
            htmlCostos += "<td>" + f.costoUnidad.toFixed(2) + "</td>";
            htmlCostos += "<td>" + f.subtotal.toFixed(2) + "</td>";
            htmlCostos += "</tr>";
          });
          htmlCostos += "</tbody></table>";
        } else {
          htmlCostos = "<p class='hint'>Para ver costos, llena la columna de costo unitario y el plan de producci√≥n.</p>";
        }

        resumenCostosDiv.innerHTML = htmlCostos;
      }

      let htmlResumen = "<div class='flex-row'><div class='badge'>Volumen final te√≥rico: <strong>" +
        formatLitros(datos.totalVolumenFinalMl) +
        "</strong></div></div>";
      resumenVolumenDiv.innerHTML = htmlResumen;

      A33HasCalculoPrevio = true;
      resultadosDiv.style.display = "block";
      const hintRes = document.getElementById("hint-resultados");
      if (hintRes) hintRes.style.display = "none";
      guardarMetaLote();
    }
    function exportarLote() {
      const datos = calcularDatosLote();
      const ahora = new Date();
      const fechaStr = ahora.toLocaleString("es-NI");
      let texto = "";
      const loteNombre = datos.loteNombre || "Lote sin nombre";
      texto += "Arcano 33 - Resumen de lote\n";
      texto += "================================\n\n";
      texto += "Lote: " + loteNombre + "\n";
      texto += "Fecha de exportaci√≥n: " + fechaStr + "\n";
      if (datos.fechaProd) {
        texto += "Fecha de producci√≥n: " + formatearFechaBonita(datos.fechaProd) + "\n";
      } else {
        texto += "Fecha de producci√≥n: ‚Äî\n";
      }
      if (datos.fechaCad) {
        texto += "Fecha de caducidad: " + formatearFechaBonita(datos.fechaCad) + "\n";
      } else {
        texto += "Fecha de caducidad: ‚Äî\n";
      }
      texto += "\n";
      texto += "Unidades por presentaci√≥n:\n";
      if (datos.unidadesPorPresentacion.length === 0) {
        texto += "- (sin unidades)\n";
      } else {
        datos.unidadesPorPresentacion.forEach(item => {
          texto += "- " + item.nombre + ": " + item.unidades + " unidad(es)\n";
        });
      }
      texto += "\n";
      texto += "Totales de materia prima:\n";
      texto += "- Vino: " + datos.totalesIngredientes.vino.toFixed(0) + " ml (" + formatLitros(datos.totalesIngredientes.vino) + ")\n";
      texto += "- Vodka: " + datos.totalesIngredientes.vodka.toFixed(0) + " ml (" + formatLitros(datos.totalesIngredientes.vodka) + ")\n";
      texto += "- Jugo: " + datos.totalesIngredientes.jugo.toFixed(0) + " ml (" + formatLitros(datos.totalesIngredientes.jugo) + ")\n";
      texto += "- Sirope: " + datos.totalesIngredientes.sirope.toFixed(0) + " ml (" + formatLitros(datos.totalesIngredientes.sirope) + ")\n";
      texto += "- Agua pura: " + datos.totalesIngredientes.agua.toFixed(0) + " ml (" + formatLitros(datos.totalesIngredientes.agua) + ")\n";
      texto += "\n";
      texto += "Volumen final te√≥rico: " + formatLitros(datos.totalVolumenFinalMl) + "\n";
      if (datos.notas) {
        texto += "\nNotas del lote:\n" + datos.notas + "\n";
      }
      const blob = new Blob([texto], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      const slug = slugify(loteNombre);
      a.download = "lote-" + slug + ".txt";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    function limpiarCantidades() {
      PRESENTACIONES.forEach(p => {
        const el = document.getElementById("plan-" + p.id);
        if (el) el.value = "";
      });
      document.getElementById("resultados").style.display = "none";
      const hintRes = document.getElementById("hint-resultados");
      if (hintRes) hintRes.style.display = "block";
      A33HasCalculoPrevio = false;
    }

    async function guardarCalculoComoLote() {
      const datos = calcularDatosLote();

      // Bloqueante: solo se permite guardar si hubo c√°lculo previo
      if (!A33HasCalculoPrevio) {
        alert("Primero calcula totales de materia prima antes de guardar el lote.");
        return;
      }

      // Plan vac√≠o: confirmaci√≥n (comportamiento existente)
      if (!datos.unidadesPorPresentacion.length) {
        if (!confirm("No hay unidades indicadas en el plan de producci√≥n. ¬øGuardar de todas formas?")) {
          return;
        }
      }

      let lotes = [];
      try {
        if (window.A33Storage && typeof A33Storage.sharedRead === 'function'){
          const rr = A33Storage.sharedRead("arcano33_lotes", []);
          lotes = Array.isArray(rr && rr.data) ? rr.data : [];
        } else {
          const raw = A33Storage.getItem("arcano33_lotes");
          if (raw) lotes = JSON.parse(raw) || [];
          if (!Array.isArray(lotes)) lotes = [];
        }
      } catch (e) {
        lotes = [];
      }

const loteInput = document.getElementById("lote");
      const rawCodigo = loteInput ? loteInput.value : "";
      let v = validarCodigoLoteFuerte(rawCodigo);
      if (!v.ok) {
        alert(v.msg || "C√≥digo inv√°lido.");
        return;
      }

      // Normalizamos a MAY√öSCULAS (evita "duplicados" por casing)
      if (loteInput) {
        A33SuppressCodigoInput = true;
        loteInput.value = v.code;
        setTimeout(() => { A33SuppressCodigoInput = false; }, 0);
      }

      let codigoFinal = v.code;
      let seqFinal = v.seq;

      // Duplicado/colisi√≥n: si ya se us√≥ entre preview y guardar, ofrecer aplicar el siguiente disponible (1 toque)
      const checkDuplicado = () => {
        const last = obtenerUltimoConsecutivoNumerico();
        const suggestedUpper = normalizarCodigoLote(A33SuggestedCode || "");
        const isSuggested = (normalizarCodigoLote(codigoFinal) === suggestedUpper);

        const yaExiste = existeCodigoEnLotes(lotes, codigoFinal);
        const quedoAtras = (typeof seqFinal === "number" && seqFinal <= last && isSuggested);
        return { yaExiste, quedoAtras };
      };

      let dup = checkDuplicado();
      if (dup.yaExiste || dup.quedoAtras) {
        const nextCode = proponerSiguienteCodigoDisponible(codigoFinal, lotes);
        const aplicar = await A33ModalDuplicadoCodigo(nextCode);
        if (!aplicar) return;

        // Aplicar
        codigoFinal = nextCode;
        v = validarCodigoLoteFuerte(codigoFinal);
        if (!v.ok) {
          alert("No se pudo asignar un c√≥digo libre. Reintent√°.");
          return;
        }
        seqFinal = v.seq;

        if (loteInput) setCodigoLoteValue(codigoFinal);
        A33CodigoLoteMode = "AUTO";
        A33AutoSeq = pad4(extraerSeqDeCodigo(codigoFinal) || 0).slice(-4);
        A33SuggestedCode = codigoFinal;
        setPillEstadoCodigo("SUGERIDO");
        try { A33Storage.setItem(STORAGE_LOTE_CODE_MODE_KEY, "AUTO"); } catch (e) {}

        // Reintentar una sola vez (sin otro modal) con datos frescos
        try {
          const raw2 = A33Storage.getItem("arcano33_lotes");
          lotes = raw2 ? (JSON.parse(raw2) || []) : [];
          if (!Array.isArray(lotes)) lotes = [];
        } catch (e) {
          lotes = [];
        }

        dup = checkDuplicado();
        if (dup.yaExiste || dup.quedoAtras) {
          alert("No se pudo asignar un c√≥digo libre. Reintent√°.");
          return;
        }
      }

      // Regla del consecutivo si el usuario edit√≥ el c√≥digo:
      // - hacia atr√°s / reutilizaci√≥n => bloquear
      const lastNow = obtenerUltimoConsecutivoNumerico();
      const suggestedNow = normalizarCodigoLote(A33SuggestedCode || "");
      const isSuggestedNow = (normalizarCodigoLote(codigoFinal) === suggestedNow);

      if (A33CodigoLoteMode === "MANUAL" && !isSuggestedNow && typeof seqFinal === "number" && seqFinal <= lastNow) {
        alert("C√≥digo no permitido: va hacia atr√°s o implica reutilizaci√≥n del consecutivo. Usa el sugerido o uno m√°s adelante.");
        return;
      }

      const mapUnits = { pulso: 0, media: 0, djeba: 0, litro: 0, galon: 0 };
      datos.unidadesPorPresentacion.forEach((item) => {
        if (!item || !item.id) return;
        if (item.id === "pulso") mapUnits.pulso = item.unidades;
        if (item.id === "media") mapUnits.media = item.unidades;
        if (item.id === "djeba") mapUnits.djeba = item.unidades;
        if (item.id === "litro") mapUnits.litro = item.unidades;
        if (item.id === "galon") mapUnits.galon = item.unidades;
      });

      const fechaProdIso = datos.fechaProdStr || hoyLocalISO();
      let caducidadIso = "";
      try {
        const cad = calcularCaducidad(fechaProdIso);
        if (cad) caducidadIso = cad.toISOString().slice(0, 10);
      } catch (e) {
        caducidadIso = "";
      }

      // Releer lotes justo antes de persistir (anti-pisadas)
      let lotesInfo = { data: lotes, meta: { rev: null } };
      try {
        if (window.A33Storage && typeof A33Storage.sharedRead === 'function'){
          lotesInfo = A33Storage.sharedRead("arcano33_lotes", []);
        } else {
          const raw = A33Storage.getItem("arcano33_lotes");
          lotesInfo = { data: raw ? (JSON.parse(raw) || []) : [], meta: { rev: null } };
        }
      } catch (e) {
        lotesInfo = { data: [], meta: { rev: null } };
      }

      let lotesActual = Array.isArray(lotesInfo.data) ? lotesInfo.data : [];
      const baseRevLotes = (lotesInfo.meta && typeof lotesInfo.meta.rev === "number") ? lotesInfo.meta.rev : null;

      const batchCode = normalizarCodigoLote(codigoFinal);
      const stableId = "batch_" + batchCode;
      const notasTrim = String(datos.notas || "").trim();

      const nuevoLote = {
        // Identidad estable (compat Lotes): batch_{BATCHCODE}
        loteId: stableId,
        batchCode: batchCode,
        id: stableId,

        fecha: fechaProdIso,
        codigo: batchCode,
        caducidad: caducidadIso || fechaProdIso,
        volTotal: Math.round(datos.totalVolumenFinalMl || 0).toString(),
        volVino: Math.round(datos.totalesIngredientes.vino || 0).toString(),
        volVodka: Math.round(datos.totalesIngredientes.vodka || 0).toString(),
        volJugo: Math.round(datos.totalesIngredientes.jugo || 0).toString(),
        volSirope: Math.round(datos.totalesIngredientes.sirope || 0).toString(),
        volAgua: Math.round(datos.totalesIngredientes.agua || 0).toString(),
        pulso: (mapUnits.pulso || 0).toString(),
        media: (mapUnits.media || 0).toString(),
        djeba: (mapUnits.djeba || 0).toString(),
        litro: (mapUnits.litro || 0).toString(),
        galon: (mapUnits.galon || 0).toString(),
        // Notas: no pisar notas existentes si aqu√≠ vienen vac√≠as
        ...(notasTrim ? { notas: notasTrim } : {}),
        createdAt: new Date().toISOString()
      };

      const isBlank = (v) => v == null || String(v).trim() === "";
      const codeCanon = (l) => normalizarCodigoLote(l && (l.codigo || l.batchCode || l.code || l.lote || ""));
      const loteSig = (l) => {
        const x = l || {};
        const pick = (k) => (x[k] == null ? "" : String(x[k]).trim());
        return [
          codeCanon(x),
          pick("fecha"),
          pick("caducidad"),
          pick("volTotal"),
          pick("volVino"),
          pick("volVodka"),
          pick("volJugo"),
          pick("volSirope"),
          pick("volAgua"),
          pick("pulso"),
          pick("media"),
          pick("djeba"),
          pick("litro"),
          pick("galon"),
        ].join("|");
      };

      // Insert/update por identidad (batchCode) con dedupe conservador
      const matchIdx = [];
      for (let i = 0; i < lotesActual.length; i++) {
        if (codeCanon(lotesActual[i]) === batchCode) matchIdx.push(i);
      }

      if (matchIdx.length > 0) {
        // Idempotencia: solo "update" si es el mismo lote (misma firma). Si difiere, bloquear.
        const sig0 = loteSig(lotesActual[matchIdx[0]]);
        const sigN = loteSig(nuevoLote);
        const allSame = matchIdx.every((i) => loteSig(lotesActual[i]) === sig0);

        if (!allSame) {
          alert("Conflicto detectado: hay m√∫ltiples registros con el mismo c√≥digo de lote. No se guard√≥ para evitar corromper data. Revis√° Control de Lotes.");
          setPillEstadoCodigo(A33CodigoLoteMode === "MANUAL" ? "EDITADO" : "SUGERIDO");
          return;
        }
        if (sig0 !== sigN) {
          alert("Conflicto detectado: ya existe un lote con ese c√≥digo y datos distintos. No se sobrescribi√≥.");
          setPillEstadoCodigo(A33CodigoLoteMode === "MANUAL" ? "EDITADO" : "SUGERIDO");
          return;
        }

        // Merge conservador: preservar campos extra (eventUsage/status/etc.) y notas/createdAt previos
        const existing = lotesActual[matchIdx[0]] || {};
        const merged = { ...existing, ...nuevoLote };

        if (!isBlank(existing.id)) merged.id = existing.id;
        if (!isBlank(existing.loteId)) merged.loteId = existing.loteId;
        if (!isBlank(existing.batchCode)) merged.batchCode = existing.batchCode;

        if (!isBlank(existing.createdAt)) merged.createdAt = existing.createdAt;
        if (!isBlank(existing.notas) && isBlank(notasTrim)) merged.notas = existing.notas;

        lotesActual[matchIdx[0]] = merged;

        // Remover duplicados id√©nticos extra (si exist√≠an)
        for (let j = matchIdx.length - 1; j >= 1; j--) {
          lotesActual.splice(matchIdx[j], 1);
        }
      } else {
        lotesActual.push(nuevoLote);
      }

      // Persistencia segura: bloquear si la data cambi√≥ entre lectura y escritura
      try {
        if (window.A33Storage && typeof A33Storage.sharedSet === 'function' && typeof A33Storage.sharedRead === 'function') {
          const r = A33Storage.sharedSet("arcano33_lotes", lotesActual, { source: 'calculadora', baseRev: baseRevLotes, conflictPolicy: 'block' });
          if (r && r.ok === false) throw new Error(r.message || "No se pudo guardar el lote.");
        } else {
          A33Storage.setItem("arcano33_lotes", JSON.stringify(lotesActual));
        }
      } catch (e) {
        alert((e && e.message) ? e.message : "No se pudo guardar el lote en el navegador.");
        setPillEstadoCodigo(A33CodigoLoteMode === "MANUAL" ? "EDITADO" : "SUGERIDO");
        return;
      }

      // Se√±al UI: OK (guardado confirmado)
      setPillEstadoCodigo("OK");

      // Side-effects SOLO despu√©s de guardar OK
      let seq4 = "";
      try {
        seq4 = commitConsecutivoDespuesDeGuardar(codigoFinal, seqFinal);
        if (/^\d{4}$/.test(String(seq4 || ""))) A33AutoSeq = seq4;
      } catch (e) {}

      let invOk = true;
      try {
        aplicarConsumoInventarioDesdeLote(datos, mapUnits);
      } catch (e) {
        invOk = false;
        console.warn('No se pudo aplicar consumo a Inventario desde Calculadora:', e);
      }

      alert(invOk
        ? "Lote guardado en el Control de Lotes interno."
        : "Lote guardado, pero no se pudo aplicar consumo a Inventario. Revis√° Inventario.");

      // Evitar doble-guardado accidental del mismo c√°lculo
      A33HasCalculoPrevio = false;

      // Preparar siguiente sugerido (preview) sin colisiones
      A33CodigoLoteMode = "AUTO";
      try { A33Storage.setItem(STORAGE_LOTE_CODE_MODE_KEY, "AUTO"); } catch (e) {}
      setPillEstadoCodigo("SUGERIDO");
      A33AutoSeq = "";
      recalcularCodigoLoteAuto({ consumeNewSeq: false });
      guardarMetaLote();
    }
function init() {
      construirTablaRecetas();
      construirTablaPlan();
      cargarRecetas();
      cargarMetaLote();
      resetNotasAlEntrar();
      document.getElementById("btn-guardar-receta").addEventListener("click", guardarRecetas);
      document.getElementById("btn-calcular").addEventListener("click", calcularTotales);
      document.getElementById("btn-limpiar").addEventListener("click", limpiarCantidades);
      const btnGuardarLote = document.getElementById("btn-guardar-lote");
      if (btnGuardarLote) btnGuardarLote.addEventListener("click", guardarCalculoComoLote);
      document.getElementById("btn-exportar").addEventListener("click", exportarLote);
      const loteInput = document.getElementById("lote");
      const fechaProdInput = document.getElementById("fecha-produccion");
      const notasInput = document.getElementById("notas");
      const btnRegenerar = document.getElementById("btn-regenerar-codigo");

      if (btnRegenerar) {
        btnRegenerar.addEventListener("click", () => {
          // Regenerar: vuelve a AUTO y recalcula el c√≥digo sugerido (preview) SIN comprometer consecutivo
          recalcularCodigoLoteAuto({ consumeNewSeq: false });
          guardarMetaLote();
        });
      }

      if (loteInput) {
        const onManual = () => {
          if (A33SuppressCodigoInput) return;
          marcarCodigoComoManual();
          guardarMetaLote();
        };
        loteInput.addEventListener("input", onManual);
        loteInput.addEventListener("change", onManual);
        loteInput.addEventListener("keyup", onManual);
        loteInput.addEventListener("focus", () => { if (!A33SuppressCodigoInput) setPillEstadoCodigo("EDITADO"); });
      }

      if (fechaProdInput) {
        const onFecha = () => {
          guardarMetaLote();
          actualizarTextoCaducidad();
          // Si est√° en AUTO, recalcula con el MISMO consecutivo (sin consumir otro)
          if (A33CodigoLoteMode === "AUTO") {
            recalcularCodigoLoteAuto({ consumeNewSeq: false });
          } else {
            // MANUAL: solo actualizamos el hint de fecha hebrea
            actualizarFechaHebrea();
          }
        };
        fechaProdInput.addEventListener("change", onFecha);
        fechaProdInput.addEventListener("keyup", onFecha);
      }

      if (notasInput) {
        // Notas no se persisten; pero seguimos limpiando key por compatibilidad del flujo
        notasInput.addEventListener("change", guardarMetaLote);
        notasInput.addEventListener("keyup", guardarMetaLote);
      }

      actualizarTextoCaducidad();
      actualizarFechaHebrea();
}

    document.addEventListener("DOMContentLoaded", init);

    // iOS/Safari puede restaurar el formulario desde BFCache al volver al m√≥dulo.
    // Esto garantiza que Notas se limpie cada vez que 're-entras' a Calculadora.
    window.addEventListener("pageshow", () => {
      try { resetNotasAlEntrar(); } catch (e) {}
    });
  </script>
  <script src="/assets/js/a33-input-ux.js?v=4.20.42"></script>
</body>
</html>
